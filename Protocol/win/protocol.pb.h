// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protocol_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[39]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocol_2eproto;
namespace RemoNet {
class Answer;
struct AnswerDefaultTypeInternal;
extern AnswerDefaultTypeInternal _Answer_default_instance_;
class BackLight;
struct BackLightDefaultTypeInternal;
extern BackLightDefaultTypeInternal _BackLight_default_instance_;
class CCAskDataChannel;
struct CCAskDataChannelDefaultTypeInternal;
extern CCAskDataChannelDefaultTypeInternal _CCAskDataChannel_default_instance_;
class CCBooStrapRep;
struct CCBooStrapRepDefaultTypeInternal;
extern CCBooStrapRepDefaultTypeInternal _CCBooStrapRep_default_instance_;
class CCBootStrapReq;
struct CCBootStrapReqDefaultTypeInternal;
extern CCBootStrapReqDefaultTypeInternal _CCBootStrapReq_default_instance_;
class CCCanMesage;
struct CCCanMesageDefaultTypeInternal;
extern CCCanMesageDefaultTypeInternal _CCCanMesage_default_instance_;
class CCManipulation;
struct CCManipulationDefaultTypeInternal;
extern CCManipulationDefaultTypeInternal _CCManipulation_default_instance_;
class CCPing;
struct CCPingDefaultTypeInternal;
extern CCPingDefaultTypeInternal _CCPing_default_instance_;
class CCRadarMessage;
struct CCRadarMessageDefaultTypeInternal;
extern CCRadarMessageDefaultTypeInternal _CCRadarMessage_default_instance_;
class CCRobotAnalog;
struct CCRobotAnalogDefaultTypeInternal;
extern CCRobotAnalogDefaultTypeInternal _CCRobotAnalog_default_instance_;
class CCStartupRep;
struct CCStartupRepDefaultTypeInternal;
extern CCStartupRepDefaultTypeInternal _CCStartupRep_default_instance_;
class CCStartupReq;
struct CCStartupReqDefaultTypeInternal;
extern CCStartupReqDefaultTypeInternal _CCStartupReq_default_instance_;
class CCSwitch;
struct CCSwitchDefaultTypeInternal;
extern CCSwitchDefaultTypeInternal _CCSwitch_default_instance_;
class CSAdd;
struct CSAddDefaultTypeInternal;
extern CSAddDefaultTypeInternal _CSAdd_default_instance_;
class CSRep;
struct CSRepDefaultTypeInternal;
extern CSRepDefaultTypeInternal _CSRep_default_instance_;
class CSReq;
struct CSReqDefaultTypeInternal;
extern CSReqDefaultTypeInternal _CSReq_default_instance_;
class CSRobot;
struct CSRobotDefaultTypeInternal;
extern CSRobotDefaultTypeInternal _CSRobot_default_instance_;
class CSSign;
struct CSSignDefaultTypeInternal;
extern CSSignDefaultTypeInternal _CSSign_default_instance_;
class CanMessage;
struct CanMessageDefaultTypeInternal;
extern CanMessageDefaultTypeInternal _CanMessage_default_instance_;
class Candidate;
struct CandidateDefaultTypeInternal;
extern CandidateDefaultTypeInternal _Candidate_default_instance_;
class Close;
struct CloseDefaultTypeInternal;
extern CloseDefaultTypeInternal _Close_default_instance_;
class FrontLight;
struct FrontLightDefaultTypeInternal;
extern FrontLightDefaultTypeInternal _FrontLight_default_instance_;
class IMuMessage;
struct IMuMessageDefaultTypeInternal;
extern IMuMessageDefaultTypeInternal _IMuMessage_default_instance_;
class Leave;
struct LeaveDefaultTypeInternal;
extern LeaveDefaultTypeInternal _Leave_default_instance_;
class LidarPoint;
struct LidarPointDefaultTypeInternal;
extern LidarPointDefaultTypeInternal _LidarPoint_default_instance_;
class Offer;
struct OfferDefaultTypeInternal;
extern OfferDefaultTypeInternal _Offer_default_instance_;
class Robot;
struct RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class SCAdd;
struct SCAddDefaultTypeInternal;
extern SCAddDefaultTypeInternal _SCAdd_default_instance_;
class SCAddRobot;
struct SCAddRobotDefaultTypeInternal;
extern SCAddRobotDefaultTypeInternal _SCAddRobot_default_instance_;
class SCDelRobot;
struct SCDelRobotDefaultTypeInternal;
extern SCDelRobotDefaultTypeInternal _SCDelRobot_default_instance_;
class SCKickOff;
struct SCKickOffDefaultTypeInternal;
extern SCKickOffDefaultTypeInternal _SCKickOff_default_instance_;
class SCRep;
struct SCRepDefaultTypeInternal;
extern SCRepDefaultTypeInternal _SCRep_default_instance_;
class SCReq;
struct SCReqDefaultTypeInternal;
extern SCReqDefaultTypeInternal _SCReq_default_instance_;
class SCRobot;
struct SCRobotDefaultTypeInternal;
extern SCRobotDefaultTypeInternal _SCRobot_default_instance_;
class SCSign;
struct SCSignDefaultTypeInternal;
extern SCSignDefaultTypeInternal _SCSign_default_instance_;
class SensorStop;
struct SensorStopDefaultTypeInternal;
extern SensorStopDefaultTypeInternal _SensorStop_default_instance_;
class StopAck;
struct StopAckDefaultTypeInternal;
extern StopAckDefaultTypeInternal _StopAck_default_instance_;
class TestTextReq;
struct TestTextReqDefaultTypeInternal;
extern TestTextReqDefaultTypeInternal _TestTextReq_default_instance_;
class Wiper;
struct WiperDefaultTypeInternal;
extern WiperDefaultTypeInternal _Wiper_default_instance_;
}  // namespace RemoNet
PROTOBUF_NAMESPACE_OPEN
template<> ::RemoNet::Answer* Arena::CreateMaybeMessage<::RemoNet::Answer>(Arena*);
template<> ::RemoNet::BackLight* Arena::CreateMaybeMessage<::RemoNet::BackLight>(Arena*);
template<> ::RemoNet::CCAskDataChannel* Arena::CreateMaybeMessage<::RemoNet::CCAskDataChannel>(Arena*);
template<> ::RemoNet::CCBooStrapRep* Arena::CreateMaybeMessage<::RemoNet::CCBooStrapRep>(Arena*);
template<> ::RemoNet::CCBootStrapReq* Arena::CreateMaybeMessage<::RemoNet::CCBootStrapReq>(Arena*);
template<> ::RemoNet::CCCanMesage* Arena::CreateMaybeMessage<::RemoNet::CCCanMesage>(Arena*);
template<> ::RemoNet::CCManipulation* Arena::CreateMaybeMessage<::RemoNet::CCManipulation>(Arena*);
template<> ::RemoNet::CCPing* Arena::CreateMaybeMessage<::RemoNet::CCPing>(Arena*);
template<> ::RemoNet::CCRadarMessage* Arena::CreateMaybeMessage<::RemoNet::CCRadarMessage>(Arena*);
template<> ::RemoNet::CCRobotAnalog* Arena::CreateMaybeMessage<::RemoNet::CCRobotAnalog>(Arena*);
template<> ::RemoNet::CCStartupRep* Arena::CreateMaybeMessage<::RemoNet::CCStartupRep>(Arena*);
template<> ::RemoNet::CCStartupReq* Arena::CreateMaybeMessage<::RemoNet::CCStartupReq>(Arena*);
template<> ::RemoNet::CCSwitch* Arena::CreateMaybeMessage<::RemoNet::CCSwitch>(Arena*);
template<> ::RemoNet::CSAdd* Arena::CreateMaybeMessage<::RemoNet::CSAdd>(Arena*);
template<> ::RemoNet::CSRep* Arena::CreateMaybeMessage<::RemoNet::CSRep>(Arena*);
template<> ::RemoNet::CSReq* Arena::CreateMaybeMessage<::RemoNet::CSReq>(Arena*);
template<> ::RemoNet::CSRobot* Arena::CreateMaybeMessage<::RemoNet::CSRobot>(Arena*);
template<> ::RemoNet::CSSign* Arena::CreateMaybeMessage<::RemoNet::CSSign>(Arena*);
template<> ::RemoNet::CanMessage* Arena::CreateMaybeMessage<::RemoNet::CanMessage>(Arena*);
template<> ::RemoNet::Candidate* Arena::CreateMaybeMessage<::RemoNet::Candidate>(Arena*);
template<> ::RemoNet::Close* Arena::CreateMaybeMessage<::RemoNet::Close>(Arena*);
template<> ::RemoNet::FrontLight* Arena::CreateMaybeMessage<::RemoNet::FrontLight>(Arena*);
template<> ::RemoNet::IMuMessage* Arena::CreateMaybeMessage<::RemoNet::IMuMessage>(Arena*);
template<> ::RemoNet::Leave* Arena::CreateMaybeMessage<::RemoNet::Leave>(Arena*);
template<> ::RemoNet::LidarPoint* Arena::CreateMaybeMessage<::RemoNet::LidarPoint>(Arena*);
template<> ::RemoNet::Offer* Arena::CreateMaybeMessage<::RemoNet::Offer>(Arena*);
template<> ::RemoNet::Robot* Arena::CreateMaybeMessage<::RemoNet::Robot>(Arena*);
template<> ::RemoNet::SCAdd* Arena::CreateMaybeMessage<::RemoNet::SCAdd>(Arena*);
template<> ::RemoNet::SCAddRobot* Arena::CreateMaybeMessage<::RemoNet::SCAddRobot>(Arena*);
template<> ::RemoNet::SCDelRobot* Arena::CreateMaybeMessage<::RemoNet::SCDelRobot>(Arena*);
template<> ::RemoNet::SCKickOff* Arena::CreateMaybeMessage<::RemoNet::SCKickOff>(Arena*);
template<> ::RemoNet::SCRep* Arena::CreateMaybeMessage<::RemoNet::SCRep>(Arena*);
template<> ::RemoNet::SCReq* Arena::CreateMaybeMessage<::RemoNet::SCReq>(Arena*);
template<> ::RemoNet::SCRobot* Arena::CreateMaybeMessage<::RemoNet::SCRobot>(Arena*);
template<> ::RemoNet::SCSign* Arena::CreateMaybeMessage<::RemoNet::SCSign>(Arena*);
template<> ::RemoNet::SensorStop* Arena::CreateMaybeMessage<::RemoNet::SensorStop>(Arena*);
template<> ::RemoNet::StopAck* Arena::CreateMaybeMessage<::RemoNet::StopAck>(Arena*);
template<> ::RemoNet::TestTextReq* Arena::CreateMaybeMessage<::RemoNet::TestTextReq>(Arena*);
template<> ::RemoNet::Wiper* Arena::CreateMaybeMessage<::RemoNet::Wiper>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace RemoNet {

enum Robot_RobotState : int {
  Robot_RobotState_Offline = 0,
  Robot_RobotState_Online = 1,
  Robot_RobotState_Busy = 2,
  Robot_RobotState_Robot_RobotState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Robot_RobotState_Robot_RobotState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Robot_RobotState_IsValid(int value);
constexpr Robot_RobotState Robot_RobotState_RobotState_MIN = Robot_RobotState_Offline;
constexpr Robot_RobotState Robot_RobotState_RobotState_MAX = Robot_RobotState_Busy;
constexpr int Robot_RobotState_RobotState_ARRAYSIZE = Robot_RobotState_RobotState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Robot_RobotState_descriptor();
template<typename T>
inline const std::string& Robot_RobotState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Robot_RobotState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Robot_RobotState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Robot_RobotState_descriptor(), enum_t_value);
}
inline bool Robot_RobotState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Robot_RobotState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Robot_RobotState>(
    Robot_RobotState_descriptor(), name, value);
}
enum CSMessage : int {
  CS_NONE = 0,
  CS_Sign = 2000,
  CS_Req = 2001,
  CS_Rep = 2002,
  CS_CancelReq = 2003,
  CS_Offer = 2004,
  CS_Answer = 2005,
  CS_Candidate = 2006,
  CS_Leave = 2007,
  CS_KeepAlive = 2008,
  CS_Add = 2009,
  CS_Robot = 2010,
  CS_CloseVideo = 2011,
  CSMessage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CSMessage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CSMessage_IsValid(int value);
constexpr CSMessage CSMessage_MIN = CS_NONE;
constexpr CSMessage CSMessage_MAX = CS_CloseVideo;
constexpr int CSMessage_ARRAYSIZE = CSMessage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CSMessage_descriptor();
template<typename T>
inline const std::string& CSMessage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CSMessage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CSMessage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CSMessage_descriptor(), enum_t_value);
}
inline bool CSMessage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CSMessage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CSMessage>(
    CSMessage_descriptor(), name, value);
}
enum SCMessage : int {
  SC_NONE = 0,
  SC_Sign = 4000,
  SC_Req = 4001,
  SC_Rep = 4002,
  SC_Cancel = 4003,
  SC_Offer = 4004,
  SC_Answer = 4005,
  SC_Candidate = 4006,
  SC_Add = 4007,
  SC_Robot = 4008,
  SC_NotifyReq = 4009,
  SC_NotifyRep = 4010,
  SC_NotifyAnswer = 4011,
  SC_NotifyOffer = 4012,
  SC_NotifyCandidate = 4013,
  SC_NotifyLeave = 4014,
  SC_NotifyCancel = 4015,
  SC_NotifyAdd = 4016,
  SC_NotifyDel = 4017,
  SC_NotifyCloseVideo = 4018,
  SC_KickOff = 4019,
  SCMessage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SCMessage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SCMessage_IsValid(int value);
constexpr SCMessage SCMessage_MIN = SC_NONE;
constexpr SCMessage SCMessage_MAX = SC_KickOff;
constexpr int SCMessage_ARRAYSIZE = SCMessage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SCMessage_descriptor();
template<typename T>
inline const std::string& SCMessage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SCMessage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SCMessage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SCMessage_descriptor(), enum_t_value);
}
inline bool SCMessage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SCMessage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SCMessage>(
    SCMessage_descriptor(), name, value);
}
enum CCMessage : int {
  CC_None = 0,
  CC_Text = 8000,
  CC_CAN = 8001,
  CC_IMU = 8002,
  CC_ASKDATACHANNEL = 8003,
  CC_Manipulation = 8004,
  CC_Radar = 8005,
  CC_Switch = 8006,
  CC_Ping = 8007,
  CC_SensorStop = 8008,
  CC_StopACK = 8009,
  CC_LIDARDATA = 8010,
  CC_RobotAnalog = 8012,
  CC_BootReq = 8013,
  CC_StartupReq = 8014,
  CC_BootRep = 8015,
  CC_StartupRep = 8016,
  CCMessage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CCMessage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CCMessage_IsValid(int value);
constexpr CCMessage CCMessage_MIN = CC_None;
constexpr CCMessage CCMessage_MAX = CC_StartupRep;
constexpr int CCMessage_ARRAYSIZE = CCMessage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CCMessage_descriptor();
template<typename T>
inline const std::string& CCMessage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CCMessage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CCMessage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CCMessage_descriptor(), enum_t_value);
}
inline bool CCMessage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CCMessage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CCMessage>(
    CCMessage_descriptor(), name, value);
}
enum VideoDesc : int {
  OK = 0,
  Busy = 1,
  Reject = 2,
  NoFound = 3,
  IsVideoing = 4,
  VideoDesc_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VideoDesc_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VideoDesc_IsValid(int value);
constexpr VideoDesc VideoDesc_MIN = OK;
constexpr VideoDesc VideoDesc_MAX = IsVideoing;
constexpr int VideoDesc_ARRAYSIZE = VideoDesc_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoDesc_descriptor();
template<typename T>
inline const std::string& VideoDesc_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoDesc>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoDesc_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VideoDesc_descriptor(), enum_t_value);
}
inline bool VideoDesc_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoDesc* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoDesc>(
    VideoDesc_descriptor(), name, value);
}
enum Gears : int {
  None = 0,
  N = 1,
  D = 2,
  R = 3,
  Gears_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Gears_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Gears_IsValid(int value);
constexpr Gears Gears_MIN = None;
constexpr Gears Gears_MAX = R;
constexpr int Gears_ARRAYSIZE = Gears_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Gears_descriptor();
template<typename T>
inline const std::string& Gears_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Gears>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Gears_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Gears_descriptor(), enum_t_value);
}
inline bool Gears_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Gears* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Gears>(
    Gears_descriptor(), name, value);
}
// ===================================================================

class CSAdd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CSAdd) */ {
 public:
  inline CSAdd() : CSAdd(nullptr) {}
  ~CSAdd() override;
  explicit constexpr CSAdd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSAdd(const CSAdd& from);
  CSAdd(CSAdd&& from) noexcept
    : CSAdd() {
    *this = ::std::move(from);
  }

  inline CSAdd& operator=(const CSAdd& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSAdd& operator=(CSAdd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSAdd& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSAdd* internal_default_instance() {
    return reinterpret_cast<const CSAdd*>(
               &_CSAdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CSAdd& a, CSAdd& b) {
    a.Swap(&b);
  }
  inline void Swap(CSAdd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSAdd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSAdd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSAdd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSAdd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSAdd& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSAdd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CSAdd";
  }
  protected:
  explicit CSAdd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialFieldNumber = 1,
    kNameFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string serial = 1;
  void clear_serial();
  const std::string& serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial();
  PROTOBUF_NODISCARD std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 type = 2;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CSAdd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class SCAdd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.SCAdd) */ {
 public:
  inline SCAdd() : SCAdd(nullptr) {}
  ~SCAdd() override;
  explicit constexpr SCAdd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCAdd(const SCAdd& from);
  SCAdd(SCAdd&& from) noexcept
    : SCAdd() {
    *this = ::std::move(from);
  }

  inline SCAdd& operator=(const SCAdd& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCAdd& operator=(SCAdd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCAdd& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCAdd* internal_default_instance() {
    return reinterpret_cast<const SCAdd*>(
               &_SCAdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SCAdd& a, SCAdd& b) {
    a.Swap(&b);
  }
  inline void Swap(SCAdd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCAdd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCAdd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCAdd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCAdd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SCAdd& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCAdd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.SCAdd";
  }
  protected:
  explicit SCAdd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kRetFieldNumber = 1,
    kUidFieldNumber = 2,
    kCidFieldNumber = 3,
  };
  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool ret = 1;
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // int32 uid = 2;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 cid = 3;
  void clear_cid();
  int32_t cid() const;
  void set_cid(int32_t value);
  private:
  int32_t _internal_cid() const;
  void _internal_set_cid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.SCAdd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool ret_;
  int32_t uid_;
  int32_t cid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class SCKickOff final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:RemoNet.SCKickOff) */ {
 public:
  inline SCKickOff() : SCKickOff(nullptr) {}
  explicit constexpr SCKickOff(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCKickOff(const SCKickOff& from);
  SCKickOff(SCKickOff&& from) noexcept
    : SCKickOff() {
    *this = ::std::move(from);
  }

  inline SCKickOff& operator=(const SCKickOff& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCKickOff& operator=(SCKickOff&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCKickOff& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCKickOff* internal_default_instance() {
    return reinterpret_cast<const SCKickOff*>(
               &_SCKickOff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SCKickOff& a, SCKickOff& b) {
    a.Swap(&b);
  }
  inline void Swap(SCKickOff* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCKickOff* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCKickOff* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCKickOff>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SCKickOff& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SCKickOff& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.SCKickOff";
  }
  protected:
  explicit SCKickOff(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RemoNet.SCKickOff)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class Robot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.Robot) */ {
 public:
  inline Robot() : Robot(nullptr) {}
  ~Robot() override;
  explicit constexpr Robot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot(const Robot& from);
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot& operator=(Robot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.Robot";
  }
  protected:
  explicit Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Robot_RobotState RobotState;
  static constexpr RobotState Offline =
    Robot_RobotState_Offline;
  static constexpr RobotState Online =
    Robot_RobotState_Online;
  static constexpr RobotState Busy =
    Robot_RobotState_Busy;
  static inline bool RobotState_IsValid(int value) {
    return Robot_RobotState_IsValid(value);
  }
  static constexpr RobotState RobotState_MIN =
    Robot_RobotState_RobotState_MIN;
  static constexpr RobotState RobotState_MAX =
    Robot_RobotState_RobotState_MAX;
  static constexpr int RobotState_ARRAYSIZE =
    Robot_RobotState_RobotState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RobotState_descriptor() {
    return Robot_RobotState_descriptor();
  }
  template<typename T>
  static inline const std::string& RobotState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RobotState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RobotState_Name.");
    return Robot_RobotState_Name(enum_t_value);
  }
  static inline bool RobotState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RobotState* value) {
    return Robot_RobotState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kRidFieldNumber = 1,
    kTypeFieldNumber = 3,
    kStateFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 rid = 1;
  void clear_rid();
  int32_t rid() const;
  void set_rid(int32_t value);
  private:
  int32_t _internal_rid() const;
  void _internal_set_rid(int32_t value);
  public:

  // int32 type = 3;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // .RemoNet.Robot.RobotState state = 4;
  void clear_state();
  ::RemoNet::Robot_RobotState state() const;
  void set_state(::RemoNet::Robot_RobotState value);
  private:
  ::RemoNet::Robot_RobotState _internal_state() const;
  void _internal_set_state(::RemoNet::Robot_RobotState value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.Robot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t rid_;
  int32_t type_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CSRobot final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:RemoNet.CSRobot) */ {
 public:
  inline CSRobot() : CSRobot(nullptr) {}
  explicit constexpr CSRobot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSRobot(const CSRobot& from);
  CSRobot(CSRobot&& from) noexcept
    : CSRobot() {
    *this = ::std::move(from);
  }

  inline CSRobot& operator=(const CSRobot& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSRobot& operator=(CSRobot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSRobot& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSRobot* internal_default_instance() {
    return reinterpret_cast<const CSRobot*>(
               &_CSRobot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CSRobot& a, CSRobot& b) {
    a.Swap(&b);
  }
  inline void Swap(CSRobot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSRobot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSRobot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSRobot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSRobot& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSRobot& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CSRobot";
  }
  protected:
  explicit CSRobot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RemoNet.CSRobot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class SCRobot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.SCRobot) */ {
 public:
  inline SCRobot() : SCRobot(nullptr) {}
  ~SCRobot() override;
  explicit constexpr SCRobot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCRobot(const SCRobot& from);
  SCRobot(SCRobot&& from) noexcept
    : SCRobot() {
    *this = ::std::move(from);
  }

  inline SCRobot& operator=(const SCRobot& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCRobot& operator=(SCRobot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCRobot& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCRobot* internal_default_instance() {
    return reinterpret_cast<const SCRobot*>(
               &_SCRobot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SCRobot& a, SCRobot& b) {
    a.Swap(&b);
  }
  inline void Swap(SCRobot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCRobot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCRobot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCRobot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCRobot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SCRobot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCRobot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.SCRobot";
  }
  protected:
  explicit SCRobot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
  };
  // repeated .RemoNet.Robot robot = 1;
  int robot_size() const;
  private:
  int _internal_robot_size() const;
  public:
  void clear_robot();
  ::RemoNet::Robot* mutable_robot(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RemoNet::Robot >*
      mutable_robot();
  private:
  const ::RemoNet::Robot& _internal_robot(int index) const;
  ::RemoNet::Robot* _internal_add_robot();
  public:
  const ::RemoNet::Robot& robot(int index) const;
  ::RemoNet::Robot* add_robot();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RemoNet::Robot >&
      robot() const;

  // @@protoc_insertion_point(class_scope:RemoNet.SCRobot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RemoNet::Robot > robot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CSSign final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CSSign) */ {
 public:
  inline CSSign() : CSSign(nullptr) {}
  ~CSSign() override;
  explicit constexpr CSSign(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSSign(const CSSign& from);
  CSSign(CSSign&& from) noexcept
    : CSSign() {
    *this = ::std::move(from);
  }

  inline CSSign& operator=(const CSSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSSign& operator=(CSSign&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSSign& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSSign* internal_default_instance() {
    return reinterpret_cast<const CSSign*>(
               &_CSSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CSSign& a, CSSign& b) {
    a.Swap(&b);
  }
  inline void Swap(CSSign* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSSign* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSSign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSSign>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSSign& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSSign& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSSign* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CSSign";
  }
  protected:
  explicit CSSign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CSSign)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class SCSign final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.SCSign) */ {
 public:
  inline SCSign() : SCSign(nullptr) {}
  ~SCSign() override;
  explicit constexpr SCSign(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCSign(const SCSign& from);
  SCSign(SCSign&& from) noexcept
    : SCSign() {
    *this = ::std::move(from);
  }

  inline SCSign& operator=(const SCSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCSign& operator=(SCSign&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCSign& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCSign* internal_default_instance() {
    return reinterpret_cast<const SCSign*>(
               &_SCSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SCSign& a, SCSign& b) {
    a.Swap(&b);
  }
  inline void Swap(SCSign* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCSign* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCSign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCSign>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCSign& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SCSign& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCSign* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.SCSign";
  }
  protected:
  explicit SCSign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kRetFieldNumber = 1,
    kUidFieldNumber = 2,
    kCidFieldNumber = 3,
  };
  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool ret = 1;
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // int32 uid = 2;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 cid = 3;
  void clear_cid();
  int32_t cid() const;
  void set_cid(int32_t value);
  private:
  int32_t _internal_cid() const;
  void _internal_set_cid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.SCSign)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool ret_;
  int32_t uid_;
  int32_t cid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CSReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CSReq) */ {
 public:
  inline CSReq() : CSReq(nullptr) {}
  ~CSReq() override;
  explicit constexpr CSReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSReq(const CSReq& from);
  CSReq(CSReq&& from) noexcept
    : CSReq() {
    *this = ::std::move(from);
  }

  inline CSReq& operator=(const CSReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSReq& operator=(CSReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSReq* internal_default_instance() {
    return reinterpret_cast<const CSReq*>(
               &_CSReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CSReq& a, CSReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CSReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CSReq";
  }
  protected:
  explicit CSReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 1,
    kIndexFieldNumber = 2,
    kEgotypeFieldNumber = 3,
  };
  // int32 peer = 1;
  void clear_peer();
  int32_t peer() const;
  void set_peer(int32_t value);
  private:
  int32_t _internal_peer() const;
  void _internal_set_peer(int32_t value);
  public:

  // int32 index = 2;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // int32 egotype = 3;
  void clear_egotype();
  int32_t egotype() const;
  void set_egotype(int32_t value);
  private:
  int32_t _internal_egotype() const;
  void _internal_set_egotype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CSReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t peer_;
  int32_t index_;
  int32_t egotype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class SCReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.SCReq) */ {
 public:
  inline SCReq() : SCReq(nullptr) {}
  ~SCReq() override;
  explicit constexpr SCReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCReq(const SCReq& from);
  SCReq(SCReq&& from) noexcept
    : SCReq() {
    *this = ::std::move(from);
  }

  inline SCReq& operator=(const SCReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCReq& operator=(SCReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCReq* internal_default_instance() {
    return reinterpret_cast<const SCReq*>(
               &_SCReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SCReq& a, SCReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SCReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SCReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.SCReq";
  }
  protected:
  explicit SCReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescFieldNumber = 1,
    kPeerFieldNumber = 2,
    kEgotypeFieldNumber = 3,
  };
  // .RemoNet.VideoDesc desc = 1;
  void clear_desc();
  ::RemoNet::VideoDesc desc() const;
  void set_desc(::RemoNet::VideoDesc value);
  private:
  ::RemoNet::VideoDesc _internal_desc() const;
  void _internal_set_desc(::RemoNet::VideoDesc value);
  public:

  // int32 peer = 2;
  void clear_peer();
  int32_t peer() const;
  void set_peer(int32_t value);
  private:
  int32_t _internal_peer() const;
  void _internal_set_peer(int32_t value);
  public:

  // int32 egotype = 3;
  void clear_egotype();
  int32_t egotype() const;
  void set_egotype(int32_t value);
  private:
  int32_t _internal_egotype() const;
  void _internal_set_egotype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.SCReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int desc_;
  int32_t peer_;
  int32_t egotype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CSRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CSRep) */ {
 public:
  inline CSRep() : CSRep(nullptr) {}
  ~CSRep() override;
  explicit constexpr CSRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSRep(const CSRep& from);
  CSRep(CSRep&& from) noexcept
    : CSRep() {
    *this = ::std::move(from);
  }

  inline CSRep& operator=(const CSRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSRep& operator=(CSRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSRep* internal_default_instance() {
    return reinterpret_cast<const CSRep*>(
               &_CSRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CSRep& a, CSRep& b) {
    a.Swap(&b);
  }
  inline void Swap(CSRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSRep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CSRep";
  }
  protected:
  explicit CSRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescFieldNumber = 1,
    kPeerFieldNumber = 2,
    kIndexFieldNumber = 3,
    kEgotypeFieldNumber = 4,
  };
  // .RemoNet.VideoDesc desc = 1;
  void clear_desc();
  ::RemoNet::VideoDesc desc() const;
  void set_desc(::RemoNet::VideoDesc value);
  private:
  ::RemoNet::VideoDesc _internal_desc() const;
  void _internal_set_desc(::RemoNet::VideoDesc value);
  public:

  // int32 peer = 2;
  void clear_peer();
  int32_t peer() const;
  void set_peer(int32_t value);
  private:
  int32_t _internal_peer() const;
  void _internal_set_peer(int32_t value);
  public:

  // int32 index = 3;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // int32 egotype = 4;
  void clear_egotype();
  int32_t egotype() const;
  void set_egotype(int32_t value);
  private:
  int32_t _internal_egotype() const;
  void _internal_set_egotype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CSRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int desc_;
  int32_t peer_;
  int32_t index_;
  int32_t egotype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class SCRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.SCRep) */ {
 public:
  inline SCRep() : SCRep(nullptr) {}
  ~SCRep() override;
  explicit constexpr SCRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCRep(const SCRep& from);
  SCRep(SCRep&& from) noexcept
    : SCRep() {
    *this = ::std::move(from);
  }

  inline SCRep& operator=(const SCRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCRep& operator=(SCRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCRep* internal_default_instance() {
    return reinterpret_cast<const SCRep*>(
               &_SCRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SCRep& a, SCRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SCRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SCRep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.SCRep";
  }
  protected:
  explicit SCRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescFieldNumber = 1,
    kIndexFieldNumber = 2,
    kEgotypeFieldNumber = 3,
    kPeerFieldNumber = 4,
  };
  // .RemoNet.VideoDesc desc = 1;
  void clear_desc();
  ::RemoNet::VideoDesc desc() const;
  void set_desc(::RemoNet::VideoDesc value);
  private:
  ::RemoNet::VideoDesc _internal_desc() const;
  void _internal_set_desc(::RemoNet::VideoDesc value);
  public:

  // int32 index = 2;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // int32 egotype = 3;
  void clear_egotype();
  int32_t egotype() const;
  void set_egotype(int32_t value);
  private:
  int32_t _internal_egotype() const;
  void _internal_set_egotype(int32_t value);
  public:

  // int32 peer = 4;
  void clear_peer();
  int32_t peer() const;
  void set_peer(int32_t value);
  private:
  int32_t _internal_peer() const;
  void _internal_set_peer(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.SCRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int desc_;
  int32_t index_;
  int32_t egotype_;
  int32_t peer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class Offer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.Offer) */ {
 public:
  inline Offer() : Offer(nullptr) {}
  ~Offer() override;
  explicit constexpr Offer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Offer(const Offer& from);
  Offer(Offer&& from) noexcept
    : Offer() {
    *this = ::std::move(from);
  }

  inline Offer& operator=(const Offer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Offer& operator=(Offer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Offer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Offer* internal_default_instance() {
    return reinterpret_cast<const Offer*>(
               &_Offer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Offer& a, Offer& b) {
    a.Swap(&b);
  }
  inline void Swap(Offer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Offer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Offer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Offer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Offer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Offer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Offer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.Offer";
  }
  protected:
  explicit Offer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 3,
    kSdpFieldNumber = 4,
    kIndexFieldNumber = 1,
    kPeerFieldNumber = 2,
  };
  // string type = 3;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string sdp = 4;
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // int32 peer = 2;
  void clear_peer();
  int32_t peer() const;
  void set_peer(int32_t value);
  private:
  int32_t _internal_peer() const;
  void _internal_set_peer(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.Offer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
  int32_t index_;
  int32_t peer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class Answer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.Answer) */ {
 public:
  inline Answer() : Answer(nullptr) {}
  ~Answer() override;
  explicit constexpr Answer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Answer(const Answer& from);
  Answer(Answer&& from) noexcept
    : Answer() {
    *this = ::std::move(from);
  }

  inline Answer& operator=(const Answer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Answer& operator=(Answer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Answer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Answer* internal_default_instance() {
    return reinterpret_cast<const Answer*>(
               &_Answer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Answer& a, Answer& b) {
    a.Swap(&b);
  }
  inline void Swap(Answer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Answer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Answer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Answer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Answer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Answer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Answer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.Answer";
  }
  protected:
  explicit Answer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 3,
    kSdpFieldNumber = 4,
    kIndexFieldNumber = 1,
    kPeerFieldNumber = 2,
  };
  // string type = 3;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string sdp = 4;
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // int32 peer = 2;
  void clear_peer();
  int32_t peer() const;
  void set_peer(int32_t value);
  private:
  int32_t _internal_peer() const;
  void _internal_set_peer(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.Answer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
  int32_t index_;
  int32_t peer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class Candidate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.Candidate) */ {
 public:
  inline Candidate() : Candidate(nullptr) {}
  ~Candidate() override;
  explicit constexpr Candidate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Candidate(const Candidate& from);
  Candidate(Candidate&& from) noexcept
    : Candidate() {
    *this = ::std::move(from);
  }

  inline Candidate& operator=(const Candidate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Candidate& operator=(Candidate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Candidate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Candidate* internal_default_instance() {
    return reinterpret_cast<const Candidate*>(
               &_Candidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Candidate& a, Candidate& b) {
    a.Swap(&b);
  }
  inline void Swap(Candidate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Candidate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Candidate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Candidate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Candidate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Candidate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Candidate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.Candidate";
  }
  protected:
  explicit Candidate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 3,
    kCandidateFieldNumber = 4,
    kSdpMidFieldNumber = 6,
    kIndexFieldNumber = 1,
    kPeerFieldNumber = 2,
    kSdpMLineIndexFieldNumber = 5,
    kEgotypeFieldNumber = 7,
  };
  // string type = 3;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string candidate = 4;
  void clear_candidate();
  const std::string& candidate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_candidate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_candidate();
  PROTOBUF_NODISCARD std::string* release_candidate();
  void set_allocated_candidate(std::string* candidate);
  private:
  const std::string& _internal_candidate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_candidate(const std::string& value);
  std::string* _internal_mutable_candidate();
  public:

  // string sdpMid = 6;
  void clear_sdpmid();
  const std::string& sdpmid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdpmid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdpmid();
  PROTOBUF_NODISCARD std::string* release_sdpmid();
  void set_allocated_sdpmid(std::string* sdpmid);
  private:
  const std::string& _internal_sdpmid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdpmid(const std::string& value);
  std::string* _internal_mutable_sdpmid();
  public:

  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // int32 peer = 2;
  void clear_peer();
  int32_t peer() const;
  void set_peer(int32_t value);
  private:
  int32_t _internal_peer() const;
  void _internal_set_peer(int32_t value);
  public:

  // int32 sdpMLineIndex = 5;
  void clear_sdpmlineindex();
  int32_t sdpmlineindex() const;
  void set_sdpmlineindex(int32_t value);
  private:
  int32_t _internal_sdpmlineindex() const;
  void _internal_set_sdpmlineindex(int32_t value);
  public:

  // int32 egotype = 7;
  void clear_egotype();
  int32_t egotype() const;
  void set_egotype(int32_t value);
  private:
  int32_t _internal_egotype() const;
  void _internal_set_egotype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.Candidate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr candidate_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdpmid_;
  int32_t index_;
  int32_t peer_;
  int32_t sdpmlineindex_;
  int32_t egotype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class Leave final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.Leave) */ {
 public:
  inline Leave() : Leave(nullptr) {}
  ~Leave() override;
  explicit constexpr Leave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Leave(const Leave& from);
  Leave(Leave&& from) noexcept
    : Leave() {
    *this = ::std::move(from);
  }

  inline Leave& operator=(const Leave& from) {
    CopyFrom(from);
    return *this;
  }
  inline Leave& operator=(Leave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Leave& default_instance() {
    return *internal_default_instance();
  }
  static inline const Leave* internal_default_instance() {
    return reinterpret_cast<const Leave*>(
               &_Leave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Leave& a, Leave& b) {
    a.Swap(&b);
  }
  inline void Swap(Leave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Leave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Leave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Leave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Leave& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Leave& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Leave* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.Leave";
  }
  protected:
  explicit Leave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 1,
    kEgotypeFieldNumber = 2,
  };
  // int32 peer = 1;
  void clear_peer();
  int32_t peer() const;
  void set_peer(int32_t value);
  private:
  int32_t _internal_peer() const;
  void _internal_set_peer(int32_t value);
  public:

  // int32 egotype = 2;
  void clear_egotype();
  int32_t egotype() const;
  void set_egotype(int32_t value);
  private:
  int32_t _internal_egotype() const;
  void _internal_set_egotype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.Leave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t peer_;
  int32_t egotype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class Close final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.Close) */ {
 public:
  inline Close() : Close(nullptr) {}
  ~Close() override;
  explicit constexpr Close(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Close(const Close& from);
  Close(Close&& from) noexcept
    : Close() {
    *this = ::std::move(from);
  }

  inline Close& operator=(const Close& from) {
    CopyFrom(from);
    return *this;
  }
  inline Close& operator=(Close&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Close& default_instance() {
    return *internal_default_instance();
  }
  static inline const Close* internal_default_instance() {
    return reinterpret_cast<const Close*>(
               &_Close_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Close& a, Close& b) {
    a.Swap(&b);
  }
  inline void Swap(Close* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Close* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Close* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Close>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Close& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Close& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Close* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.Close";
  }
  protected:
  explicit Close(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 1,
    kEgotypeFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  // int32 peer = 1;
  void clear_peer();
  int32_t peer() const;
  void set_peer(int32_t value);
  private:
  int32_t _internal_peer() const;
  void _internal_set_peer(int32_t value);
  public:

  // int32 egotype = 2;
  void clear_egotype();
  int32_t egotype() const;
  void set_egotype(int32_t value);
  private:
  int32_t _internal_egotype() const;
  void _internal_set_egotype(int32_t value);
  public:

  // int32 index = 3;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.Close)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t peer_;
  int32_t egotype_;
  int32_t index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class TestTextReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.TestTextReq) */ {
 public:
  inline TestTextReq() : TestTextReq(nullptr) {}
  ~TestTextReq() override;
  explicit constexpr TestTextReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestTextReq(const TestTextReq& from);
  TestTextReq(TestTextReq&& from) noexcept
    : TestTextReq() {
    *this = ::std::move(from);
  }

  inline TestTextReq& operator=(const TestTextReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestTextReq& operator=(TestTextReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestTextReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestTextReq* internal_default_instance() {
    return reinterpret_cast<const TestTextReq*>(
               &_TestTextReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TestTextReq& a, TestTextReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TestTextReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestTextReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestTextReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestTextReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestTextReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TestTextReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTextReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.TestTextReq";
  }
  protected:
  explicit TestTextReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.TestTextReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CanMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CanMessage) */ {
 public:
  inline CanMessage() : CanMessage(nullptr) {}
  ~CanMessage() override;
  explicit constexpr CanMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CanMessage(const CanMessage& from);
  CanMessage(CanMessage&& from) noexcept
    : CanMessage() {
    *this = ::std::move(from);
  }

  inline CanMessage& operator=(const CanMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CanMessage& operator=(CanMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CanMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CanMessage* internal_default_instance() {
    return reinterpret_cast<const CanMessage*>(
               &_CanMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CanMessage& a, CanMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CanMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CanMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CanMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CanMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CanMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CanMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CanMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CanMessage";
  }
  protected:
  explicit CanMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kHeadFieldNumber = 1,
    kCanidFieldNumber = 2,
  };
  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 head = 1;
  void clear_head();
  int32_t head() const;
  void set_head(int32_t value);
  private:
  int32_t _internal_head() const;
  void _internal_set_head(int32_t value);
  public:

  // int32 canid = 2;
  void clear_canid();
  int32_t canid() const;
  void set_canid(int32_t value);
  private:
  int32_t _internal_canid() const;
  void _internal_set_canid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CanMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int32_t head_;
  int32_t canid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CCCanMesage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CCCanMesage) */ {
 public:
  inline CCCanMesage() : CCCanMesage(nullptr) {}
  ~CCCanMesage() override;
  explicit constexpr CCCanMesage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCCanMesage(const CCCanMesage& from);
  CCCanMesage(CCCanMesage&& from) noexcept
    : CCCanMesage() {
    *this = ::std::move(from);
  }

  inline CCCanMesage& operator=(const CCCanMesage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCCanMesage& operator=(CCCanMesage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCCanMesage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCCanMesage* internal_default_instance() {
    return reinterpret_cast<const CCCanMesage*>(
               &_CCCanMesage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CCCanMesage& a, CCCanMesage& b) {
    a.Swap(&b);
  }
  inline void Swap(CCCanMesage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCCanMesage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCCanMesage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCCanMesage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCCanMesage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCCanMesage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCCanMesage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CCCanMesage";
  }
  protected:
  explicit CCCanMesage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kIslidarFieldNumber = 1,
  };
  // repeated .RemoNet.CanMessage message = 2;
  int message_size() const;
  private:
  int _internal_message_size() const;
  public:
  void clear_message();
  ::RemoNet::CanMessage* mutable_message(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RemoNet::CanMessage >*
      mutable_message();
  private:
  const ::RemoNet::CanMessage& _internal_message(int index) const;
  ::RemoNet::CanMessage* _internal_add_message();
  public:
  const ::RemoNet::CanMessage& message(int index) const;
  ::RemoNet::CanMessage* add_message();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RemoNet::CanMessage >&
      message() const;

  // bool islidar = 1;
  void clear_islidar();
  bool islidar() const;
  void set_islidar(bool value);
  private:
  bool _internal_islidar() const;
  void _internal_set_islidar(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CCCanMesage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RemoNet::CanMessage > message_;
  bool islidar_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class Wiper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.Wiper) */ {
 public:
  inline Wiper() : Wiper(nullptr) {}
  ~Wiper() override;
  explicit constexpr Wiper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wiper(const Wiper& from);
  Wiper(Wiper&& from) noexcept
    : Wiper() {
    *this = ::std::move(from);
  }

  inline Wiper& operator=(const Wiper& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wiper& operator=(Wiper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wiper& default_instance() {
    return *internal_default_instance();
  }
  static inline const Wiper* internal_default_instance() {
    return reinterpret_cast<const Wiper*>(
               &_Wiper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Wiper& a, Wiper& b) {
    a.Swap(&b);
  }
  inline void Swap(Wiper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wiper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wiper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wiper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Wiper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Wiper& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wiper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.Wiper";
  }
  protected:
  explicit Wiper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetFieldNumber = 1,
  };
  // bool ret = 1;
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.Wiper)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class FrontLight final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.FrontLight) */ {
 public:
  inline FrontLight() : FrontLight(nullptr) {}
  ~FrontLight() override;
  explicit constexpr FrontLight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrontLight(const FrontLight& from);
  FrontLight(FrontLight&& from) noexcept
    : FrontLight() {
    *this = ::std::move(from);
  }

  inline FrontLight& operator=(const FrontLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrontLight& operator=(FrontLight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrontLight& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrontLight* internal_default_instance() {
    return reinterpret_cast<const FrontLight*>(
               &_FrontLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(FrontLight& a, FrontLight& b) {
    a.Swap(&b);
  }
  inline void Swap(FrontLight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrontLight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrontLight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrontLight>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrontLight& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FrontLight& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrontLight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.FrontLight";
  }
  protected:
  explicit FrontLight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetFieldNumber = 1,
  };
  // bool ret = 1;
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.FrontLight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class BackLight final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.BackLight) */ {
 public:
  inline BackLight() : BackLight(nullptr) {}
  ~BackLight() override;
  explicit constexpr BackLight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BackLight(const BackLight& from);
  BackLight(BackLight&& from) noexcept
    : BackLight() {
    *this = ::std::move(from);
  }

  inline BackLight& operator=(const BackLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackLight& operator=(BackLight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackLight& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackLight* internal_default_instance() {
    return reinterpret_cast<const BackLight*>(
               &_BackLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(BackLight& a, BackLight& b) {
    a.Swap(&b);
  }
  inline void Swap(BackLight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackLight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BackLight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BackLight>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BackLight& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BackLight& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BackLight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.BackLight";
  }
  protected:
  explicit BackLight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetFieldNumber = 1,
  };
  // bool ret = 1;
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.BackLight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CCAskDataChannel final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:RemoNet.CCAskDataChannel) */ {
 public:
  inline CCAskDataChannel() : CCAskDataChannel(nullptr) {}
  explicit constexpr CCAskDataChannel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCAskDataChannel(const CCAskDataChannel& from);
  CCAskDataChannel(CCAskDataChannel&& from) noexcept
    : CCAskDataChannel() {
    *this = ::std::move(from);
  }

  inline CCAskDataChannel& operator=(const CCAskDataChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCAskDataChannel& operator=(CCAskDataChannel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCAskDataChannel& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCAskDataChannel* internal_default_instance() {
    return reinterpret_cast<const CCAskDataChannel*>(
               &_CCAskDataChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CCAskDataChannel& a, CCAskDataChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(CCAskDataChannel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCAskDataChannel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCAskDataChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCAskDataChannel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CCAskDataChannel& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CCAskDataChannel& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CCAskDataChannel";
  }
  protected:
  explicit CCAskDataChannel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RemoNet.CCAskDataChannel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class IMuMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.IMuMessage) */ {
 public:
  inline IMuMessage() : IMuMessage(nullptr) {}
  ~IMuMessage() override;
  explicit constexpr IMuMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMuMessage(const IMuMessage& from);
  IMuMessage(IMuMessage&& from) noexcept
    : IMuMessage() {
    *this = ::std::move(from);
  }

  inline IMuMessage& operator=(const IMuMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMuMessage& operator=(IMuMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMuMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMuMessage* internal_default_instance() {
    return reinterpret_cast<const IMuMessage*>(
               &_IMuMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(IMuMessage& a, IMuMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(IMuMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMuMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IMuMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IMuMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMuMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMuMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMuMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.IMuMessage";
  }
  protected:
  explicit IMuMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRxFieldNumber = 1,
    kRyFieldNumber = 2,
  };
  // float rx = 1;
  void clear_rx();
  float rx() const;
  void set_rx(float value);
  private:
  float _internal_rx() const;
  void _internal_set_rx(float value);
  public:

  // float ry = 2;
  void clear_ry();
  float ry() const;
  void set_ry(float value);
  private:
  float _internal_ry() const;
  void _internal_set_ry(float value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.IMuMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float rx_;
  float ry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CCPing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CCPing) */ {
 public:
  inline CCPing() : CCPing(nullptr) {}
  ~CCPing() override;
  explicit constexpr CCPing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCPing(const CCPing& from);
  CCPing(CCPing&& from) noexcept
    : CCPing() {
    *this = ::std::move(from);
  }

  inline CCPing& operator=(const CCPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCPing& operator=(CCPing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCPing& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCPing* internal_default_instance() {
    return reinterpret_cast<const CCPing*>(
               &_CCPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CCPing& a, CCPing& b) {
    a.Swap(&b);
  }
  inline void Swap(CCPing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCPing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCPing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCPing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCPing& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCPing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CCPing";
  }
  protected:
  explicit CCPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTickFieldNumber = 1,
  };
  // int64 tick = 1;
  void clear_tick();
  int64_t tick() const;
  void set_tick(int64_t value);
  private:
  int64_t _internal_tick() const;
  void _internal_set_tick(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CCPing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t tick_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CCRadarMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CCRadarMessage) */ {
 public:
  inline CCRadarMessage() : CCRadarMessage(nullptr) {}
  ~CCRadarMessage() override;
  explicit constexpr CCRadarMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCRadarMessage(const CCRadarMessage& from);
  CCRadarMessage(CCRadarMessage&& from) noexcept
    : CCRadarMessage() {
    *this = ::std::move(from);
  }

  inline CCRadarMessage& operator=(const CCRadarMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCRadarMessage& operator=(CCRadarMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCRadarMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCRadarMessage* internal_default_instance() {
    return reinterpret_cast<const CCRadarMessage*>(
               &_CCRadarMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CCRadarMessage& a, CCRadarMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CCRadarMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCRadarMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCRadarMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCRadarMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCRadarMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCRadarMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCRadarMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CCRadarMessage";
  }
  protected:
  explicit CCRadarMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadar0FieldNumber = 1,
    kRadar1FieldNumber = 2,
    kRadar2FieldNumber = 3,
    kRadar3FieldNumber = 4,
    kRadar4FieldNumber = 5,
    kRadar5FieldNumber = 6,
  };
  // int32 radar0 = 1;
  void clear_radar0();
  int32_t radar0() const;
  void set_radar0(int32_t value);
  private:
  int32_t _internal_radar0() const;
  void _internal_set_radar0(int32_t value);
  public:

  // int32 radar1 = 2;
  void clear_radar1();
  int32_t radar1() const;
  void set_radar1(int32_t value);
  private:
  int32_t _internal_radar1() const;
  void _internal_set_radar1(int32_t value);
  public:

  // int32 radar2 = 3;
  void clear_radar2();
  int32_t radar2() const;
  void set_radar2(int32_t value);
  private:
  int32_t _internal_radar2() const;
  void _internal_set_radar2(int32_t value);
  public:

  // int32 radar3 = 4;
  void clear_radar3();
  int32_t radar3() const;
  void set_radar3(int32_t value);
  private:
  int32_t _internal_radar3() const;
  void _internal_set_radar3(int32_t value);
  public:

  // int32 radar4 = 5;
  void clear_radar4();
  int32_t radar4() const;
  void set_radar4(int32_t value);
  private:
  int32_t _internal_radar4() const;
  void _internal_set_radar4(int32_t value);
  public:

  // int32 radar5 = 6;
  void clear_radar5();
  int32_t radar5() const;
  void set_radar5(int32_t value);
  private:
  int32_t _internal_radar5() const;
  void _internal_set_radar5(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CCRadarMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t radar0_;
  int32_t radar1_;
  int32_t radar2_;
  int32_t radar3_;
  int32_t radar4_;
  int32_t radar5_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CCRobotAnalog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CCRobotAnalog) */ {
 public:
  inline CCRobotAnalog() : CCRobotAnalog(nullptr) {}
  ~CCRobotAnalog() override;
  explicit constexpr CCRobotAnalog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCRobotAnalog(const CCRobotAnalog& from);
  CCRobotAnalog(CCRobotAnalog&& from) noexcept
    : CCRobotAnalog() {
    *this = ::std::move(from);
  }

  inline CCRobotAnalog& operator=(const CCRobotAnalog& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCRobotAnalog& operator=(CCRobotAnalog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCRobotAnalog& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCRobotAnalog* internal_default_instance() {
    return reinterpret_cast<const CCRobotAnalog*>(
               &_CCRobotAnalog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CCRobotAnalog& a, CCRobotAnalog& b) {
    a.Swap(&b);
  }
  inline void Swap(CCRobotAnalog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCRobotAnalog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCRobotAnalog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCRobotAnalog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCRobotAnalog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCRobotAnalog& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCRobotAnalog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CCRobotAnalog";
  }
  protected:
  explicit CCRobotAnalog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteerFieldNumber = 1,
    kArmFieldNumber = 2,
    kBucketFieldNumber = 3,
    kThrottleFieldNumber = 4,
    kBrakeFieldNumber = 5,
    kGearsFieldNumber = 10,
    kEmergencyFieldNumber = 8,
    kResumeFieldNumber = 9,
    kFrontlightFieldNumber = 11,
    kBacklightFieldNumber = 12,
    kWipeFieldNumber = 13,
  };
  // int32 steer = 1;
  void clear_steer();
  int32_t steer() const;
  void set_steer(int32_t value);
  private:
  int32_t _internal_steer() const;
  void _internal_set_steer(int32_t value);
  public:

  // int32 arm = 2;
  void clear_arm();
  int32_t arm() const;
  void set_arm(int32_t value);
  private:
  int32_t _internal_arm() const;
  void _internal_set_arm(int32_t value);
  public:

  // int32 bucket = 3;
  void clear_bucket();
  int32_t bucket() const;
  void set_bucket(int32_t value);
  private:
  int32_t _internal_bucket() const;
  void _internal_set_bucket(int32_t value);
  public:

  // int32 throttle = 4;
  void clear_throttle();
  int32_t throttle() const;
  void set_throttle(int32_t value);
  private:
  int32_t _internal_throttle() const;
  void _internal_set_throttle(int32_t value);
  public:

  // int32 brake = 5;
  void clear_brake();
  int32_t brake() const;
  void set_brake(int32_t value);
  private:
  int32_t _internal_brake() const;
  void _internal_set_brake(int32_t value);
  public:

  // .RemoNet.Gears gears = 10;
  void clear_gears();
  ::RemoNet::Gears gears() const;
  void set_gears(::RemoNet::Gears value);
  private:
  ::RemoNet::Gears _internal_gears() const;
  void _internal_set_gears(::RemoNet::Gears value);
  public:

  // bool emergency = 8;
  void clear_emergency();
  bool emergency() const;
  void set_emergency(bool value);
  private:
  bool _internal_emergency() const;
  void _internal_set_emergency(bool value);
  public:

  // bool resume = 9;
  void clear_resume();
  bool resume() const;
  void set_resume(bool value);
  private:
  bool _internal_resume() const;
  void _internal_set_resume(bool value);
  public:

  // bool frontlight = 11;
  void clear_frontlight();
  bool frontlight() const;
  void set_frontlight(bool value);
  private:
  bool _internal_frontlight() const;
  void _internal_set_frontlight(bool value);
  public:

  // bool backlight = 12;
  void clear_backlight();
  bool backlight() const;
  void set_backlight(bool value);
  private:
  bool _internal_backlight() const;
  void _internal_set_backlight(bool value);
  public:

  // bool wipe = 13;
  void clear_wipe();
  bool wipe() const;
  void set_wipe(bool value);
  private:
  bool _internal_wipe() const;
  void _internal_set_wipe(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CCRobotAnalog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t steer_;
  int32_t arm_;
  int32_t bucket_;
  int32_t throttle_;
  int32_t brake_;
  int gears_;
  bool emergency_;
  bool resume_;
  bool frontlight_;
  bool backlight_;
  bool wipe_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CCBootStrapReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:RemoNet.CCBootStrapReq) */ {
 public:
  inline CCBootStrapReq() : CCBootStrapReq(nullptr) {}
  explicit constexpr CCBootStrapReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCBootStrapReq(const CCBootStrapReq& from);
  CCBootStrapReq(CCBootStrapReq&& from) noexcept
    : CCBootStrapReq() {
    *this = ::std::move(from);
  }

  inline CCBootStrapReq& operator=(const CCBootStrapReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCBootStrapReq& operator=(CCBootStrapReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCBootStrapReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCBootStrapReq* internal_default_instance() {
    return reinterpret_cast<const CCBootStrapReq*>(
               &_CCBootStrapReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CCBootStrapReq& a, CCBootStrapReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CCBootStrapReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCBootStrapReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCBootStrapReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCBootStrapReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CCBootStrapReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CCBootStrapReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CCBootStrapReq";
  }
  protected:
  explicit CCBootStrapReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RemoNet.CCBootStrapReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CCBooStrapRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CCBooStrapRep) */ {
 public:
  inline CCBooStrapRep() : CCBooStrapRep(nullptr) {}
  ~CCBooStrapRep() override;
  explicit constexpr CCBooStrapRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCBooStrapRep(const CCBooStrapRep& from);
  CCBooStrapRep(CCBooStrapRep&& from) noexcept
    : CCBooStrapRep() {
    *this = ::std::move(from);
  }

  inline CCBooStrapRep& operator=(const CCBooStrapRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCBooStrapRep& operator=(CCBooStrapRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCBooStrapRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCBooStrapRep* internal_default_instance() {
    return reinterpret_cast<const CCBooStrapRep*>(
               &_CCBooStrapRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CCBooStrapRep& a, CCBooStrapRep& b) {
    a.Swap(&b);
  }
  inline void Swap(CCBooStrapRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCBooStrapRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCBooStrapRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCBooStrapRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCBooStrapRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCBooStrapRep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCBooStrapRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CCBooStrapRep";
  }
  protected:
  explicit CCBooStrapRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetFieldNumber = 1,
  };
  // bool ret = 1;
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CCBooStrapRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CCStartupReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:RemoNet.CCStartupReq) */ {
 public:
  inline CCStartupReq() : CCStartupReq(nullptr) {}
  explicit constexpr CCStartupReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCStartupReq(const CCStartupReq& from);
  CCStartupReq(CCStartupReq&& from) noexcept
    : CCStartupReq() {
    *this = ::std::move(from);
  }

  inline CCStartupReq& operator=(const CCStartupReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCStartupReq& operator=(CCStartupReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCStartupReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCStartupReq* internal_default_instance() {
    return reinterpret_cast<const CCStartupReq*>(
               &_CCStartupReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CCStartupReq& a, CCStartupReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CCStartupReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCStartupReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCStartupReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCStartupReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CCStartupReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CCStartupReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CCStartupReq";
  }
  protected:
  explicit CCStartupReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RemoNet.CCStartupReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CCStartupRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CCStartupRep) */ {
 public:
  inline CCStartupRep() : CCStartupRep(nullptr) {}
  ~CCStartupRep() override;
  explicit constexpr CCStartupRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCStartupRep(const CCStartupRep& from);
  CCStartupRep(CCStartupRep&& from) noexcept
    : CCStartupRep() {
    *this = ::std::move(from);
  }

  inline CCStartupRep& operator=(const CCStartupRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCStartupRep& operator=(CCStartupRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCStartupRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCStartupRep* internal_default_instance() {
    return reinterpret_cast<const CCStartupRep*>(
               &_CCStartupRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CCStartupRep& a, CCStartupRep& b) {
    a.Swap(&b);
  }
  inline void Swap(CCStartupRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCStartupRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCStartupRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCStartupRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCStartupRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCStartupRep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCStartupRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CCStartupRep";
  }
  protected:
  explicit CCStartupRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetFieldNumber = 1,
  };
  // bool ret = 1;
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CCStartupRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CCSwitch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CCSwitch) */ {
 public:
  inline CCSwitch() : CCSwitch(nullptr) {}
  ~CCSwitch() override;
  explicit constexpr CCSwitch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCSwitch(const CCSwitch& from);
  CCSwitch(CCSwitch&& from) noexcept
    : CCSwitch() {
    *this = ::std::move(from);
  }

  inline CCSwitch& operator=(const CCSwitch& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCSwitch& operator=(CCSwitch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCSwitch& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCSwitch* internal_default_instance() {
    return reinterpret_cast<const CCSwitch*>(
               &_CCSwitch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CCSwitch& a, CCSwitch& b) {
    a.Swap(&b);
  }
  inline void Swap(CCSwitch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCSwitch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCSwitch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCSwitch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCSwitch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCSwitch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCSwitch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CCSwitch";
  }
  protected:
  explicit CCSwitch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrontFieldNumber = 1,
  };
  // bool front = 1;
  void clear_front();
  bool front() const;
  void set_front(bool value);
  private:
  bool _internal_front() const;
  void _internal_set_front(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CCSwitch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool front_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class LidarPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.LidarPoint) */ {
 public:
  inline LidarPoint() : LidarPoint(nullptr) {}
  ~LidarPoint() override;
  explicit constexpr LidarPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LidarPoint(const LidarPoint& from);
  LidarPoint(LidarPoint&& from) noexcept
    : LidarPoint() {
    *this = ::std::move(from);
  }

  inline LidarPoint& operator=(const LidarPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline LidarPoint& operator=(LidarPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LidarPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const LidarPoint* internal_default_instance() {
    return reinterpret_cast<const LidarPoint*>(
               &_LidarPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(LidarPoint& a, LidarPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(LidarPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LidarPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LidarPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LidarPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LidarPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LidarPoint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LidarPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.LidarPoint";
  }
  protected:
  explicit LidarPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 8,
    kFrameIdFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kSeqFieldNumber = 2,
    kHeightFieldNumber = 4,
    kWidthFieldNumber = 5,
    kIsDenseFieldNumber = 6,
    kIsLeftFieldNumber = 7,
  };
  // repeated float data = 8;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  float _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_data() const;
  void _internal_add_data(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_data();
  public:
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data();

  // optional string frame_id = 3;
  bool has_frame_id() const;
  private:
  bool _internal_has_frame_id() const;
  public:
  void clear_frame_id();
  const std::string& frame_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_id();
  PROTOBUF_NODISCARD std::string* release_frame_id();
  void set_allocated_frame_id(std::string* frame_id);
  private:
  const std::string& _internal_frame_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_id(const std::string& value);
  std::string* _internal_mutable_frame_id();
  public:

  // optional double timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  double timestamp() const;
  void set_timestamp(double value);
  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);
  public:

  // optional uint32 seq = 2;
  bool has_seq() const;
  private:
  bool _internal_has_seq() const;
  public:
  void clear_seq();
  uint32_t seq() const;
  void set_seq(uint32_t value);
  private:
  uint32_t _internal_seq() const;
  void _internal_set_seq(uint32_t value);
  public:

  // optional uint32 height = 4;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // optional uint32 width = 5;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional bool is_dense = 6;
  bool has_is_dense() const;
  private:
  bool _internal_has_is_dense() const;
  public:
  void clear_is_dense();
  bool is_dense() const;
  void set_is_dense(bool value);
  private:
  bool _internal_is_dense() const;
  void _internal_set_is_dense(bool value);
  public:

  // optional bool is_left = 7;
  bool has_is_left() const;
  private:
  bool _internal_has_is_left() const;
  public:
  void clear_is_left();
  bool is_left() const;
  void set_is_left(bool value);
  private:
  bool _internal_is_left() const;
  void _internal_set_is_left(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.LidarPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_id_;
  double timestamp_;
  uint32_t seq_;
  uint32_t height_;
  uint32_t width_;
  bool is_dense_;
  bool is_left_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class SensorStop final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:RemoNet.SensorStop) */ {
 public:
  inline SensorStop() : SensorStop(nullptr) {}
  explicit constexpr SensorStop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorStop(const SensorStop& from);
  SensorStop(SensorStop&& from) noexcept
    : SensorStop() {
    *this = ::std::move(from);
  }

  inline SensorStop& operator=(const SensorStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorStop& operator=(SensorStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorStop* internal_default_instance() {
    return reinterpret_cast<const SensorStop*>(
               &_SensorStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SensorStop& a, SensorStop& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorStop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SensorStop& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SensorStop& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.SensorStop";
  }
  protected:
  explicit SensorStop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RemoNet.SensorStop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class StopAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:RemoNet.StopAck) */ {
 public:
  inline StopAck() : StopAck(nullptr) {}
  explicit constexpr StopAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopAck(const StopAck& from);
  StopAck(StopAck&& from) noexcept
    : StopAck() {
    *this = ::std::move(from);
  }

  inline StopAck& operator=(const StopAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopAck& operator=(StopAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopAck* internal_default_instance() {
    return reinterpret_cast<const StopAck*>(
               &_StopAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(StopAck& a, StopAck& b) {
    a.Swap(&b);
  }
  inline void Swap(StopAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.StopAck";
  }
  protected:
  explicit StopAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RemoNet.StopAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CCManipulation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.CCManipulation) */ {
 public:
  inline CCManipulation() : CCManipulation(nullptr) {}
  ~CCManipulation() override;
  explicit constexpr CCManipulation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCManipulation(const CCManipulation& from);
  CCManipulation(CCManipulation&& from) noexcept
    : CCManipulation() {
    *this = ::std::move(from);
  }

  inline CCManipulation& operator=(const CCManipulation& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCManipulation& operator=(CCManipulation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCManipulation& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCManipulation* internal_default_instance() {
    return reinterpret_cast<const CCManipulation*>(
               &_CCManipulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CCManipulation& a, CCManipulation& b) {
    a.Swap(&b);
  }
  inline void Swap(CCManipulation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCManipulation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCManipulation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCManipulation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCManipulation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCManipulation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCManipulation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.CCManipulation";
  }
  protected:
  explicit CCManipulation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorFieldNumber = 1,
    kCarFieldNumber = 2,
  };
  // bytes sensor = 1;
  void clear_sensor();
  const std::string& sensor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensor();
  PROTOBUF_NODISCARD std::string* release_sensor();
  void set_allocated_sensor(std::string* sensor);
  private:
  const std::string& _internal_sensor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor(const std::string& value);
  std::string* _internal_mutable_sensor();
  public:

  // bytes car = 2;
  void clear_car();
  const std::string& car() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_car(ArgT0&& arg0, ArgT... args);
  std::string* mutable_car();
  PROTOBUF_NODISCARD std::string* release_car();
  void set_allocated_car(std::string* car);
  private:
  const std::string& _internal_car() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_car(const std::string& value);
  std::string* _internal_mutable_car();
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.CCManipulation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr car_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class SCAddRobot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.SCAddRobot) */ {
 public:
  inline SCAddRobot() : SCAddRobot(nullptr) {}
  ~SCAddRobot() override;
  explicit constexpr SCAddRobot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCAddRobot(const SCAddRobot& from);
  SCAddRobot(SCAddRobot&& from) noexcept
    : SCAddRobot() {
    *this = ::std::move(from);
  }

  inline SCAddRobot& operator=(const SCAddRobot& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCAddRobot& operator=(SCAddRobot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCAddRobot& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCAddRobot* internal_default_instance() {
    return reinterpret_cast<const SCAddRobot*>(
               &_SCAddRobot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(SCAddRobot& a, SCAddRobot& b) {
    a.Swap(&b);
  }
  inline void Swap(SCAddRobot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCAddRobot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCAddRobot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCAddRobot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCAddRobot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SCAddRobot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCAddRobot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.SCAddRobot";
  }
  protected:
  explicit SCAddRobot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
  };
  // .RemoNet.Robot robot = 1;
  bool has_robot() const;
  private:
  bool _internal_has_robot() const;
  public:
  void clear_robot();
  const ::RemoNet::Robot& robot() const;
  PROTOBUF_NODISCARD ::RemoNet::Robot* release_robot();
  ::RemoNet::Robot* mutable_robot();
  void set_allocated_robot(::RemoNet::Robot* robot);
  private:
  const ::RemoNet::Robot& _internal_robot() const;
  ::RemoNet::Robot* _internal_mutable_robot();
  public:
  void unsafe_arena_set_allocated_robot(
      ::RemoNet::Robot* robot);
  ::RemoNet::Robot* unsafe_arena_release_robot();

  // @@protoc_insertion_point(class_scope:RemoNet.SCAddRobot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::RemoNet::Robot* robot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class SCDelRobot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoNet.SCDelRobot) */ {
 public:
  inline SCDelRobot() : SCDelRobot(nullptr) {}
  ~SCDelRobot() override;
  explicit constexpr SCDelRobot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCDelRobot(const SCDelRobot& from);
  SCDelRobot(SCDelRobot&& from) noexcept
    : SCDelRobot() {
    *this = ::std::move(from);
  }

  inline SCDelRobot& operator=(const SCDelRobot& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCDelRobot& operator=(SCDelRobot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCDelRobot& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCDelRobot* internal_default_instance() {
    return reinterpret_cast<const SCDelRobot*>(
               &_SCDelRobot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SCDelRobot& a, SCDelRobot& b) {
    a.Swap(&b);
  }
  inline void Swap(SCDelRobot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCDelRobot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCDelRobot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCDelRobot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCDelRobot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SCDelRobot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCDelRobot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoNet.SCDelRobot";
  }
  protected:
  explicit SCDelRobot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 1,
    kEgotypeFieldNumber = 2,
  };
  // int32 peer = 1;
  void clear_peer();
  int32_t peer() const;
  void set_peer(int32_t value);
  private:
  int32_t _internal_peer() const;
  void _internal_set_peer(int32_t value);
  public:

  // int32 egotype = 2;
  void clear_egotype();
  int32_t egotype() const;
  void set_egotype(int32_t value);
  private:
  int32_t _internal_egotype() const;
  void _internal_set_egotype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoNet.SCDelRobot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t peer_;
  int32_t egotype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CSAdd

// string serial = 1;
inline void CSAdd::clear_serial() {
  serial_.ClearToEmpty();
}
inline const std::string& CSAdd::serial() const {
  // @@protoc_insertion_point(field_get:RemoNet.CSAdd.serial)
  return _internal_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSAdd::set_serial(ArgT0&& arg0, ArgT... args) {
 
 serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.CSAdd.serial)
}
inline std::string* CSAdd::mutable_serial() {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:RemoNet.CSAdd.serial)
  return _s;
}
inline const std::string& CSAdd::_internal_serial() const {
  return serial_.Get();
}
inline void CSAdd::_internal_set_serial(const std::string& value) {
  
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSAdd::_internal_mutable_serial() {
  
  return serial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSAdd::release_serial() {
  // @@protoc_insertion_point(field_release:RemoNet.CSAdd.serial)
  return serial_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CSAdd::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    
  } else {
    
  }
  serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.CSAdd.serial)
}

// int32 type = 2;
inline void CSAdd::clear_type() {
  type_ = 0;
}
inline int32_t CSAdd::_internal_type() const {
  return type_;
}
inline int32_t CSAdd::type() const {
  // @@protoc_insertion_point(field_get:RemoNet.CSAdd.type)
  return _internal_type();
}
inline void CSAdd::_internal_set_type(int32_t value) {
  
  type_ = value;
}
inline void CSAdd::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RemoNet.CSAdd.type)
}

// string name = 3;
inline void CSAdd::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CSAdd::name() const {
  // @@protoc_insertion_point(field_get:RemoNet.CSAdd.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSAdd::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.CSAdd.name)
}
inline std::string* CSAdd::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:RemoNet.CSAdd.name)
  return _s;
}
inline const std::string& CSAdd::_internal_name() const {
  return name_.Get();
}
inline void CSAdd::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSAdd::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSAdd::release_name() {
  // @@protoc_insertion_point(field_release:RemoNet.CSAdd.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CSAdd::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.CSAdd.name)
}

// -------------------------------------------------------------------

// SCAdd

// bool ret = 1;
inline void SCAdd::clear_ret() {
  ret_ = false;
}
inline bool SCAdd::_internal_ret() const {
  return ret_;
}
inline bool SCAdd::ret() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCAdd.ret)
  return _internal_ret();
}
inline void SCAdd::_internal_set_ret(bool value) {
  
  ret_ = value;
}
inline void SCAdd::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCAdd.ret)
}

// int32 uid = 2;
inline void SCAdd::clear_uid() {
  uid_ = 0;
}
inline int32_t SCAdd::_internal_uid() const {
  return uid_;
}
inline int32_t SCAdd::uid() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCAdd.uid)
  return _internal_uid();
}
inline void SCAdd::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void SCAdd::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCAdd.uid)
}

// int32 cid = 3;
inline void SCAdd::clear_cid() {
  cid_ = 0;
}
inline int32_t SCAdd::_internal_cid() const {
  return cid_;
}
inline int32_t SCAdd::cid() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCAdd.cid)
  return _internal_cid();
}
inline void SCAdd::_internal_set_cid(int32_t value) {
  
  cid_ = value;
}
inline void SCAdd::set_cid(int32_t value) {
  _internal_set_cid(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCAdd.cid)
}

// string name = 4;
inline void SCAdd::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& SCAdd::name() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCAdd.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCAdd::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.SCAdd.name)
}
inline std::string* SCAdd::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:RemoNet.SCAdd.name)
  return _s;
}
inline const std::string& SCAdd::_internal_name() const {
  return name_.Get();
}
inline void SCAdd::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SCAdd::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SCAdd::release_name() {
  // @@protoc_insertion_point(field_release:RemoNet.SCAdd.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SCAdd::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.SCAdd.name)
}

// -------------------------------------------------------------------

// SCKickOff

// -------------------------------------------------------------------

// Robot

// int32 rid = 1;
inline void Robot::clear_rid() {
  rid_ = 0;
}
inline int32_t Robot::_internal_rid() const {
  return rid_;
}
inline int32_t Robot::rid() const {
  // @@protoc_insertion_point(field_get:RemoNet.Robot.rid)
  return _internal_rid();
}
inline void Robot::_internal_set_rid(int32_t value) {
  
  rid_ = value;
}
inline void Robot::set_rid(int32_t value) {
  _internal_set_rid(value);
  // @@protoc_insertion_point(field_set:RemoNet.Robot.rid)
}

// string name = 2;
inline void Robot::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Robot::name() const {
  // @@protoc_insertion_point(field_get:RemoNet.Robot.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.Robot.name)
}
inline std::string* Robot::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:RemoNet.Robot.name)
  return _s;
}
inline const std::string& Robot::_internal_name() const {
  return name_.Get();
}
inline void Robot::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot::release_name() {
  // @@protoc_insertion_point(field_release:RemoNet.Robot.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Robot::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.Robot.name)
}

// int32 type = 3;
inline void Robot::clear_type() {
  type_ = 0;
}
inline int32_t Robot::_internal_type() const {
  return type_;
}
inline int32_t Robot::type() const {
  // @@protoc_insertion_point(field_get:RemoNet.Robot.type)
  return _internal_type();
}
inline void Robot::_internal_set_type(int32_t value) {
  
  type_ = value;
}
inline void Robot::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RemoNet.Robot.type)
}

// .RemoNet.Robot.RobotState state = 4;
inline void Robot::clear_state() {
  state_ = 0;
}
inline ::RemoNet::Robot_RobotState Robot::_internal_state() const {
  return static_cast< ::RemoNet::Robot_RobotState >(state_);
}
inline ::RemoNet::Robot_RobotState Robot::state() const {
  // @@protoc_insertion_point(field_get:RemoNet.Robot.state)
  return _internal_state();
}
inline void Robot::_internal_set_state(::RemoNet::Robot_RobotState value) {
  
  state_ = value;
}
inline void Robot::set_state(::RemoNet::Robot_RobotState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:RemoNet.Robot.state)
}

// -------------------------------------------------------------------

// CSRobot

// -------------------------------------------------------------------

// SCRobot

// repeated .RemoNet.Robot robot = 1;
inline int SCRobot::_internal_robot_size() const {
  return robot_.size();
}
inline int SCRobot::robot_size() const {
  return _internal_robot_size();
}
inline void SCRobot::clear_robot() {
  robot_.Clear();
}
inline ::RemoNet::Robot* SCRobot::mutable_robot(int index) {
  // @@protoc_insertion_point(field_mutable:RemoNet.SCRobot.robot)
  return robot_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RemoNet::Robot >*
SCRobot::mutable_robot() {
  // @@protoc_insertion_point(field_mutable_list:RemoNet.SCRobot.robot)
  return &robot_;
}
inline const ::RemoNet::Robot& SCRobot::_internal_robot(int index) const {
  return robot_.Get(index);
}
inline const ::RemoNet::Robot& SCRobot::robot(int index) const {
  // @@protoc_insertion_point(field_get:RemoNet.SCRobot.robot)
  return _internal_robot(index);
}
inline ::RemoNet::Robot* SCRobot::_internal_add_robot() {
  return robot_.Add();
}
inline ::RemoNet::Robot* SCRobot::add_robot() {
  ::RemoNet::Robot* _add = _internal_add_robot();
  // @@protoc_insertion_point(field_add:RemoNet.SCRobot.robot)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RemoNet::Robot >&
SCRobot::robot() const {
  // @@protoc_insertion_point(field_list:RemoNet.SCRobot.robot)
  return robot_;
}

// -------------------------------------------------------------------

// CSSign

// string account = 1;
inline void CSSign::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& CSSign::account() const {
  // @@protoc_insertion_point(field_get:RemoNet.CSSign.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSSign::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.CSSign.account)
}
inline std::string* CSSign::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:RemoNet.CSSign.account)
  return _s;
}
inline const std::string& CSSign::_internal_account() const {
  return account_.Get();
}
inline void CSSign::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSSign::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSSign::release_account() {
  // @@protoc_insertion_point(field_release:RemoNet.CSSign.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CSSign::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.CSSign.account)
}

// string password = 2;
inline void CSSign::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& CSSign::password() const {
  // @@protoc_insertion_point(field_get:RemoNet.CSSign.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSSign::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.CSSign.password)
}
inline std::string* CSSign::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:RemoNet.CSSign.password)
  return _s;
}
inline const std::string& CSSign::_internal_password() const {
  return password_.Get();
}
inline void CSSign::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSSign::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSSign::release_password() {
  // @@protoc_insertion_point(field_release:RemoNet.CSSign.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CSSign::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.CSSign.password)
}

// -------------------------------------------------------------------

// SCSign

// bool ret = 1;
inline void SCSign::clear_ret() {
  ret_ = false;
}
inline bool SCSign::_internal_ret() const {
  return ret_;
}
inline bool SCSign::ret() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCSign.ret)
  return _internal_ret();
}
inline void SCSign::_internal_set_ret(bool value) {
  
  ret_ = value;
}
inline void SCSign::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCSign.ret)
}

// int32 uid = 2;
inline void SCSign::clear_uid() {
  uid_ = 0;
}
inline int32_t SCSign::_internal_uid() const {
  return uid_;
}
inline int32_t SCSign::uid() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCSign.uid)
  return _internal_uid();
}
inline void SCSign::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void SCSign::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCSign.uid)
}

// int32 cid = 3;
inline void SCSign::clear_cid() {
  cid_ = 0;
}
inline int32_t SCSign::_internal_cid() const {
  return cid_;
}
inline int32_t SCSign::cid() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCSign.cid)
  return _internal_cid();
}
inline void SCSign::_internal_set_cid(int32_t value) {
  
  cid_ = value;
}
inline void SCSign::set_cid(int32_t value) {
  _internal_set_cid(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCSign.cid)
}

// string name = 4;
inline void SCSign::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& SCSign::name() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCSign.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCSign::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.SCSign.name)
}
inline std::string* SCSign::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:RemoNet.SCSign.name)
  return _s;
}
inline const std::string& SCSign::_internal_name() const {
  return name_.Get();
}
inline void SCSign::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SCSign::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SCSign::release_name() {
  // @@protoc_insertion_point(field_release:RemoNet.SCSign.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SCSign::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.SCSign.name)
}

// -------------------------------------------------------------------

// CSReq

// int32 peer = 1;
inline void CSReq::clear_peer() {
  peer_ = 0;
}
inline int32_t CSReq::_internal_peer() const {
  return peer_;
}
inline int32_t CSReq::peer() const {
  // @@protoc_insertion_point(field_get:RemoNet.CSReq.peer)
  return _internal_peer();
}
inline void CSReq::_internal_set_peer(int32_t value) {
  
  peer_ = value;
}
inline void CSReq::set_peer(int32_t value) {
  _internal_set_peer(value);
  // @@protoc_insertion_point(field_set:RemoNet.CSReq.peer)
}

// int32 index = 2;
inline void CSReq::clear_index() {
  index_ = 0;
}
inline int32_t CSReq::_internal_index() const {
  return index_;
}
inline int32_t CSReq::index() const {
  // @@protoc_insertion_point(field_get:RemoNet.CSReq.index)
  return _internal_index();
}
inline void CSReq::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void CSReq::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:RemoNet.CSReq.index)
}

// int32 egotype = 3;
inline void CSReq::clear_egotype() {
  egotype_ = 0;
}
inline int32_t CSReq::_internal_egotype() const {
  return egotype_;
}
inline int32_t CSReq::egotype() const {
  // @@protoc_insertion_point(field_get:RemoNet.CSReq.egotype)
  return _internal_egotype();
}
inline void CSReq::_internal_set_egotype(int32_t value) {
  
  egotype_ = value;
}
inline void CSReq::set_egotype(int32_t value) {
  _internal_set_egotype(value);
  // @@protoc_insertion_point(field_set:RemoNet.CSReq.egotype)
}

// -------------------------------------------------------------------

// SCReq

// .RemoNet.VideoDesc desc = 1;
inline void SCReq::clear_desc() {
  desc_ = 0;
}
inline ::RemoNet::VideoDesc SCReq::_internal_desc() const {
  return static_cast< ::RemoNet::VideoDesc >(desc_);
}
inline ::RemoNet::VideoDesc SCReq::desc() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCReq.desc)
  return _internal_desc();
}
inline void SCReq::_internal_set_desc(::RemoNet::VideoDesc value) {
  
  desc_ = value;
}
inline void SCReq::set_desc(::RemoNet::VideoDesc value) {
  _internal_set_desc(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCReq.desc)
}

// int32 peer = 2;
inline void SCReq::clear_peer() {
  peer_ = 0;
}
inline int32_t SCReq::_internal_peer() const {
  return peer_;
}
inline int32_t SCReq::peer() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCReq.peer)
  return _internal_peer();
}
inline void SCReq::_internal_set_peer(int32_t value) {
  
  peer_ = value;
}
inline void SCReq::set_peer(int32_t value) {
  _internal_set_peer(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCReq.peer)
}

// int32 egotype = 3;
inline void SCReq::clear_egotype() {
  egotype_ = 0;
}
inline int32_t SCReq::_internal_egotype() const {
  return egotype_;
}
inline int32_t SCReq::egotype() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCReq.egotype)
  return _internal_egotype();
}
inline void SCReq::_internal_set_egotype(int32_t value) {
  
  egotype_ = value;
}
inline void SCReq::set_egotype(int32_t value) {
  _internal_set_egotype(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCReq.egotype)
}

// -------------------------------------------------------------------

// CSRep

// .RemoNet.VideoDesc desc = 1;
inline void CSRep::clear_desc() {
  desc_ = 0;
}
inline ::RemoNet::VideoDesc CSRep::_internal_desc() const {
  return static_cast< ::RemoNet::VideoDesc >(desc_);
}
inline ::RemoNet::VideoDesc CSRep::desc() const {
  // @@protoc_insertion_point(field_get:RemoNet.CSRep.desc)
  return _internal_desc();
}
inline void CSRep::_internal_set_desc(::RemoNet::VideoDesc value) {
  
  desc_ = value;
}
inline void CSRep::set_desc(::RemoNet::VideoDesc value) {
  _internal_set_desc(value);
  // @@protoc_insertion_point(field_set:RemoNet.CSRep.desc)
}

// int32 peer = 2;
inline void CSRep::clear_peer() {
  peer_ = 0;
}
inline int32_t CSRep::_internal_peer() const {
  return peer_;
}
inline int32_t CSRep::peer() const {
  // @@protoc_insertion_point(field_get:RemoNet.CSRep.peer)
  return _internal_peer();
}
inline void CSRep::_internal_set_peer(int32_t value) {
  
  peer_ = value;
}
inline void CSRep::set_peer(int32_t value) {
  _internal_set_peer(value);
  // @@protoc_insertion_point(field_set:RemoNet.CSRep.peer)
}

// int32 index = 3;
inline void CSRep::clear_index() {
  index_ = 0;
}
inline int32_t CSRep::_internal_index() const {
  return index_;
}
inline int32_t CSRep::index() const {
  // @@protoc_insertion_point(field_get:RemoNet.CSRep.index)
  return _internal_index();
}
inline void CSRep::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void CSRep::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:RemoNet.CSRep.index)
}

// int32 egotype = 4;
inline void CSRep::clear_egotype() {
  egotype_ = 0;
}
inline int32_t CSRep::_internal_egotype() const {
  return egotype_;
}
inline int32_t CSRep::egotype() const {
  // @@protoc_insertion_point(field_get:RemoNet.CSRep.egotype)
  return _internal_egotype();
}
inline void CSRep::_internal_set_egotype(int32_t value) {
  
  egotype_ = value;
}
inline void CSRep::set_egotype(int32_t value) {
  _internal_set_egotype(value);
  // @@protoc_insertion_point(field_set:RemoNet.CSRep.egotype)
}

// -------------------------------------------------------------------

// SCRep

// .RemoNet.VideoDesc desc = 1;
inline void SCRep::clear_desc() {
  desc_ = 0;
}
inline ::RemoNet::VideoDesc SCRep::_internal_desc() const {
  return static_cast< ::RemoNet::VideoDesc >(desc_);
}
inline ::RemoNet::VideoDesc SCRep::desc() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCRep.desc)
  return _internal_desc();
}
inline void SCRep::_internal_set_desc(::RemoNet::VideoDesc value) {
  
  desc_ = value;
}
inline void SCRep::set_desc(::RemoNet::VideoDesc value) {
  _internal_set_desc(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCRep.desc)
}

// int32 index = 2;
inline void SCRep::clear_index() {
  index_ = 0;
}
inline int32_t SCRep::_internal_index() const {
  return index_;
}
inline int32_t SCRep::index() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCRep.index)
  return _internal_index();
}
inline void SCRep::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void SCRep::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCRep.index)
}

// int32 egotype = 3;
inline void SCRep::clear_egotype() {
  egotype_ = 0;
}
inline int32_t SCRep::_internal_egotype() const {
  return egotype_;
}
inline int32_t SCRep::egotype() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCRep.egotype)
  return _internal_egotype();
}
inline void SCRep::_internal_set_egotype(int32_t value) {
  
  egotype_ = value;
}
inline void SCRep::set_egotype(int32_t value) {
  _internal_set_egotype(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCRep.egotype)
}

// int32 peer = 4;
inline void SCRep::clear_peer() {
  peer_ = 0;
}
inline int32_t SCRep::_internal_peer() const {
  return peer_;
}
inline int32_t SCRep::peer() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCRep.peer)
  return _internal_peer();
}
inline void SCRep::_internal_set_peer(int32_t value) {
  
  peer_ = value;
}
inline void SCRep::set_peer(int32_t value) {
  _internal_set_peer(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCRep.peer)
}

// -------------------------------------------------------------------

// Offer

// int32 index = 1;
inline void Offer::clear_index() {
  index_ = 0;
}
inline int32_t Offer::_internal_index() const {
  return index_;
}
inline int32_t Offer::index() const {
  // @@protoc_insertion_point(field_get:RemoNet.Offer.index)
  return _internal_index();
}
inline void Offer::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void Offer::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:RemoNet.Offer.index)
}

// int32 peer = 2;
inline void Offer::clear_peer() {
  peer_ = 0;
}
inline int32_t Offer::_internal_peer() const {
  return peer_;
}
inline int32_t Offer::peer() const {
  // @@protoc_insertion_point(field_get:RemoNet.Offer.peer)
  return _internal_peer();
}
inline void Offer::_internal_set_peer(int32_t value) {
  
  peer_ = value;
}
inline void Offer::set_peer(int32_t value) {
  _internal_set_peer(value);
  // @@protoc_insertion_point(field_set:RemoNet.Offer.peer)
}

// string type = 3;
inline void Offer::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Offer::type() const {
  // @@protoc_insertion_point(field_get:RemoNet.Offer.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Offer::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.Offer.type)
}
inline std::string* Offer::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:RemoNet.Offer.type)
  return _s;
}
inline const std::string& Offer::_internal_type() const {
  return type_.Get();
}
inline void Offer::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Offer::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Offer::release_type() {
  // @@protoc_insertion_point(field_release:RemoNet.Offer.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Offer::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.Offer.type)
}

// string sdp = 4;
inline void Offer::clear_sdp() {
  sdp_.ClearToEmpty();
}
inline const std::string& Offer::sdp() const {
  // @@protoc_insertion_point(field_get:RemoNet.Offer.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Offer::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 sdp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.Offer.sdp)
}
inline std::string* Offer::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:RemoNet.Offer.sdp)
  return _s;
}
inline const std::string& Offer::_internal_sdp() const {
  return sdp_.Get();
}
inline void Offer::_internal_set_sdp(const std::string& value) {
  
  sdp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Offer::_internal_mutable_sdp() {
  
  return sdp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Offer::release_sdp() {
  // @@protoc_insertion_point(field_release:RemoNet.Offer.sdp)
  return sdp_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Offer::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  sdp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdp,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.Offer.sdp)
}

// -------------------------------------------------------------------

// Answer

// int32 index = 1;
inline void Answer::clear_index() {
  index_ = 0;
}
inline int32_t Answer::_internal_index() const {
  return index_;
}
inline int32_t Answer::index() const {
  // @@protoc_insertion_point(field_get:RemoNet.Answer.index)
  return _internal_index();
}
inline void Answer::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void Answer::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:RemoNet.Answer.index)
}

// int32 peer = 2;
inline void Answer::clear_peer() {
  peer_ = 0;
}
inline int32_t Answer::_internal_peer() const {
  return peer_;
}
inline int32_t Answer::peer() const {
  // @@protoc_insertion_point(field_get:RemoNet.Answer.peer)
  return _internal_peer();
}
inline void Answer::_internal_set_peer(int32_t value) {
  
  peer_ = value;
}
inline void Answer::set_peer(int32_t value) {
  _internal_set_peer(value);
  // @@protoc_insertion_point(field_set:RemoNet.Answer.peer)
}

// string type = 3;
inline void Answer::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Answer::type() const {
  // @@protoc_insertion_point(field_get:RemoNet.Answer.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Answer::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.Answer.type)
}
inline std::string* Answer::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:RemoNet.Answer.type)
  return _s;
}
inline const std::string& Answer::_internal_type() const {
  return type_.Get();
}
inline void Answer::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Answer::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Answer::release_type() {
  // @@protoc_insertion_point(field_release:RemoNet.Answer.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Answer::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.Answer.type)
}

// string sdp = 4;
inline void Answer::clear_sdp() {
  sdp_.ClearToEmpty();
}
inline const std::string& Answer::sdp() const {
  // @@protoc_insertion_point(field_get:RemoNet.Answer.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Answer::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 sdp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.Answer.sdp)
}
inline std::string* Answer::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:RemoNet.Answer.sdp)
  return _s;
}
inline const std::string& Answer::_internal_sdp() const {
  return sdp_.Get();
}
inline void Answer::_internal_set_sdp(const std::string& value) {
  
  sdp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Answer::_internal_mutable_sdp() {
  
  return sdp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Answer::release_sdp() {
  // @@protoc_insertion_point(field_release:RemoNet.Answer.sdp)
  return sdp_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Answer::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  sdp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdp,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.Answer.sdp)
}

// -------------------------------------------------------------------

// Candidate

// int32 index = 1;
inline void Candidate::clear_index() {
  index_ = 0;
}
inline int32_t Candidate::_internal_index() const {
  return index_;
}
inline int32_t Candidate::index() const {
  // @@protoc_insertion_point(field_get:RemoNet.Candidate.index)
  return _internal_index();
}
inline void Candidate::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void Candidate::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:RemoNet.Candidate.index)
}

// int32 peer = 2;
inline void Candidate::clear_peer() {
  peer_ = 0;
}
inline int32_t Candidate::_internal_peer() const {
  return peer_;
}
inline int32_t Candidate::peer() const {
  // @@protoc_insertion_point(field_get:RemoNet.Candidate.peer)
  return _internal_peer();
}
inline void Candidate::_internal_set_peer(int32_t value) {
  
  peer_ = value;
}
inline void Candidate::set_peer(int32_t value) {
  _internal_set_peer(value);
  // @@protoc_insertion_point(field_set:RemoNet.Candidate.peer)
}

// string type = 3;
inline void Candidate::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Candidate::type() const {
  // @@protoc_insertion_point(field_get:RemoNet.Candidate.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.Candidate.type)
}
inline std::string* Candidate::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:RemoNet.Candidate.type)
  return _s;
}
inline const std::string& Candidate::_internal_type() const {
  return type_.Get();
}
inline void Candidate::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Candidate::release_type() {
  // @@protoc_insertion_point(field_release:RemoNet.Candidate.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Candidate::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.Candidate.type)
}

// string candidate = 4;
inline void Candidate::clear_candidate() {
  candidate_.ClearToEmpty();
}
inline const std::string& Candidate::candidate() const {
  // @@protoc_insertion_point(field_get:RemoNet.Candidate.candidate)
  return _internal_candidate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_candidate(ArgT0&& arg0, ArgT... args) {
 
 candidate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.Candidate.candidate)
}
inline std::string* Candidate::mutable_candidate() {
  std::string* _s = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:RemoNet.Candidate.candidate)
  return _s;
}
inline const std::string& Candidate::_internal_candidate() const {
  return candidate_.Get();
}
inline void Candidate::_internal_set_candidate(const std::string& value) {
  
  candidate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_candidate() {
  
  return candidate_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Candidate::release_candidate() {
  // @@protoc_insertion_point(field_release:RemoNet.Candidate.candidate)
  return candidate_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Candidate::set_allocated_candidate(std::string* candidate) {
  if (candidate != nullptr) {
    
  } else {
    
  }
  candidate_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), candidate,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (candidate_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    candidate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.Candidate.candidate)
}

// int32 sdpMLineIndex = 5;
inline void Candidate::clear_sdpmlineindex() {
  sdpmlineindex_ = 0;
}
inline int32_t Candidate::_internal_sdpmlineindex() const {
  return sdpmlineindex_;
}
inline int32_t Candidate::sdpmlineindex() const {
  // @@protoc_insertion_point(field_get:RemoNet.Candidate.sdpMLineIndex)
  return _internal_sdpmlineindex();
}
inline void Candidate::_internal_set_sdpmlineindex(int32_t value) {
  
  sdpmlineindex_ = value;
}
inline void Candidate::set_sdpmlineindex(int32_t value) {
  _internal_set_sdpmlineindex(value);
  // @@protoc_insertion_point(field_set:RemoNet.Candidate.sdpMLineIndex)
}

// string sdpMid = 6;
inline void Candidate::clear_sdpmid() {
  sdpmid_.ClearToEmpty();
}
inline const std::string& Candidate::sdpmid() const {
  // @@protoc_insertion_point(field_get:RemoNet.Candidate.sdpMid)
  return _internal_sdpmid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_sdpmid(ArgT0&& arg0, ArgT... args) {
 
 sdpmid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.Candidate.sdpMid)
}
inline std::string* Candidate::mutable_sdpmid() {
  std::string* _s = _internal_mutable_sdpmid();
  // @@protoc_insertion_point(field_mutable:RemoNet.Candidate.sdpMid)
  return _s;
}
inline const std::string& Candidate::_internal_sdpmid() const {
  return sdpmid_.Get();
}
inline void Candidate::_internal_set_sdpmid(const std::string& value) {
  
  sdpmid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_sdpmid() {
  
  return sdpmid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Candidate::release_sdpmid() {
  // @@protoc_insertion_point(field_release:RemoNet.Candidate.sdpMid)
  return sdpmid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Candidate::set_allocated_sdpmid(std::string* sdpmid) {
  if (sdpmid != nullptr) {
    
  } else {
    
  }
  sdpmid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdpmid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdpmid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdpmid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.Candidate.sdpMid)
}

// int32 egotype = 7;
inline void Candidate::clear_egotype() {
  egotype_ = 0;
}
inline int32_t Candidate::_internal_egotype() const {
  return egotype_;
}
inline int32_t Candidate::egotype() const {
  // @@protoc_insertion_point(field_get:RemoNet.Candidate.egotype)
  return _internal_egotype();
}
inline void Candidate::_internal_set_egotype(int32_t value) {
  
  egotype_ = value;
}
inline void Candidate::set_egotype(int32_t value) {
  _internal_set_egotype(value);
  // @@protoc_insertion_point(field_set:RemoNet.Candidate.egotype)
}

// -------------------------------------------------------------------

// Leave

// int32 peer = 1;
inline void Leave::clear_peer() {
  peer_ = 0;
}
inline int32_t Leave::_internal_peer() const {
  return peer_;
}
inline int32_t Leave::peer() const {
  // @@protoc_insertion_point(field_get:RemoNet.Leave.peer)
  return _internal_peer();
}
inline void Leave::_internal_set_peer(int32_t value) {
  
  peer_ = value;
}
inline void Leave::set_peer(int32_t value) {
  _internal_set_peer(value);
  // @@protoc_insertion_point(field_set:RemoNet.Leave.peer)
}

// int32 egotype = 2;
inline void Leave::clear_egotype() {
  egotype_ = 0;
}
inline int32_t Leave::_internal_egotype() const {
  return egotype_;
}
inline int32_t Leave::egotype() const {
  // @@protoc_insertion_point(field_get:RemoNet.Leave.egotype)
  return _internal_egotype();
}
inline void Leave::_internal_set_egotype(int32_t value) {
  
  egotype_ = value;
}
inline void Leave::set_egotype(int32_t value) {
  _internal_set_egotype(value);
  // @@protoc_insertion_point(field_set:RemoNet.Leave.egotype)
}

// -------------------------------------------------------------------

// Close

// int32 peer = 1;
inline void Close::clear_peer() {
  peer_ = 0;
}
inline int32_t Close::_internal_peer() const {
  return peer_;
}
inline int32_t Close::peer() const {
  // @@protoc_insertion_point(field_get:RemoNet.Close.peer)
  return _internal_peer();
}
inline void Close::_internal_set_peer(int32_t value) {
  
  peer_ = value;
}
inline void Close::set_peer(int32_t value) {
  _internal_set_peer(value);
  // @@protoc_insertion_point(field_set:RemoNet.Close.peer)
}

// int32 egotype = 2;
inline void Close::clear_egotype() {
  egotype_ = 0;
}
inline int32_t Close::_internal_egotype() const {
  return egotype_;
}
inline int32_t Close::egotype() const {
  // @@protoc_insertion_point(field_get:RemoNet.Close.egotype)
  return _internal_egotype();
}
inline void Close::_internal_set_egotype(int32_t value) {
  
  egotype_ = value;
}
inline void Close::set_egotype(int32_t value) {
  _internal_set_egotype(value);
  // @@protoc_insertion_point(field_set:RemoNet.Close.egotype)
}

// int32 index = 3;
inline void Close::clear_index() {
  index_ = 0;
}
inline int32_t Close::_internal_index() const {
  return index_;
}
inline int32_t Close::index() const {
  // @@protoc_insertion_point(field_get:RemoNet.Close.index)
  return _internal_index();
}
inline void Close::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void Close::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:RemoNet.Close.index)
}

// -------------------------------------------------------------------

// TestTextReq

// string text = 1;
inline void TestTextReq::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& TestTextReq::text() const {
  // @@protoc_insertion_point(field_get:RemoNet.TestTextReq.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestTextReq::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.TestTextReq.text)
}
inline std::string* TestTextReq::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:RemoNet.TestTextReq.text)
  return _s;
}
inline const std::string& TestTextReq::_internal_text() const {
  return text_.Get();
}
inline void TestTextReq::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TestTextReq::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TestTextReq::release_text() {
  // @@protoc_insertion_point(field_release:RemoNet.TestTextReq.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TestTextReq::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.TestTextReq.text)
}

// -------------------------------------------------------------------

// CanMessage

// int32 head = 1;
inline void CanMessage::clear_head() {
  head_ = 0;
}
inline int32_t CanMessage::_internal_head() const {
  return head_;
}
inline int32_t CanMessage::head() const {
  // @@protoc_insertion_point(field_get:RemoNet.CanMessage.head)
  return _internal_head();
}
inline void CanMessage::_internal_set_head(int32_t value) {
  
  head_ = value;
}
inline void CanMessage::set_head(int32_t value) {
  _internal_set_head(value);
  // @@protoc_insertion_point(field_set:RemoNet.CanMessage.head)
}

// int32 canid = 2;
inline void CanMessage::clear_canid() {
  canid_ = 0;
}
inline int32_t CanMessage::_internal_canid() const {
  return canid_;
}
inline int32_t CanMessage::canid() const {
  // @@protoc_insertion_point(field_get:RemoNet.CanMessage.canid)
  return _internal_canid();
}
inline void CanMessage::_internal_set_canid(int32_t value) {
  
  canid_ = value;
}
inline void CanMessage::set_canid(int32_t value) {
  _internal_set_canid(value);
  // @@protoc_insertion_point(field_set:RemoNet.CanMessage.canid)
}

// bytes data = 3;
inline void CanMessage::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& CanMessage::data() const {
  // @@protoc_insertion_point(field_get:RemoNet.CanMessage.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CanMessage::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.CanMessage.data)
}
inline std::string* CanMessage::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:RemoNet.CanMessage.data)
  return _s;
}
inline const std::string& CanMessage::_internal_data() const {
  return data_.Get();
}
inline void CanMessage::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CanMessage::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CanMessage::release_data() {
  // @@protoc_insertion_point(field_release:RemoNet.CanMessage.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CanMessage::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.CanMessage.data)
}

// -------------------------------------------------------------------

// CCCanMesage

// bool islidar = 1;
inline void CCCanMesage::clear_islidar() {
  islidar_ = false;
}
inline bool CCCanMesage::_internal_islidar() const {
  return islidar_;
}
inline bool CCCanMesage::islidar() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCCanMesage.islidar)
  return _internal_islidar();
}
inline void CCCanMesage::_internal_set_islidar(bool value) {
  
  islidar_ = value;
}
inline void CCCanMesage::set_islidar(bool value) {
  _internal_set_islidar(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCCanMesage.islidar)
}

// repeated .RemoNet.CanMessage message = 2;
inline int CCCanMesage::_internal_message_size() const {
  return message_.size();
}
inline int CCCanMesage::message_size() const {
  return _internal_message_size();
}
inline void CCCanMesage::clear_message() {
  message_.Clear();
}
inline ::RemoNet::CanMessage* CCCanMesage::mutable_message(int index) {
  // @@protoc_insertion_point(field_mutable:RemoNet.CCCanMesage.message)
  return message_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RemoNet::CanMessage >*
CCCanMesage::mutable_message() {
  // @@protoc_insertion_point(field_mutable_list:RemoNet.CCCanMesage.message)
  return &message_;
}
inline const ::RemoNet::CanMessage& CCCanMesage::_internal_message(int index) const {
  return message_.Get(index);
}
inline const ::RemoNet::CanMessage& CCCanMesage::message(int index) const {
  // @@protoc_insertion_point(field_get:RemoNet.CCCanMesage.message)
  return _internal_message(index);
}
inline ::RemoNet::CanMessage* CCCanMesage::_internal_add_message() {
  return message_.Add();
}
inline ::RemoNet::CanMessage* CCCanMesage::add_message() {
  ::RemoNet::CanMessage* _add = _internal_add_message();
  // @@protoc_insertion_point(field_add:RemoNet.CCCanMesage.message)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RemoNet::CanMessage >&
CCCanMesage::message() const {
  // @@protoc_insertion_point(field_list:RemoNet.CCCanMesage.message)
  return message_;
}

// -------------------------------------------------------------------

// Wiper

// bool ret = 1;
inline void Wiper::clear_ret() {
  ret_ = false;
}
inline bool Wiper::_internal_ret() const {
  return ret_;
}
inline bool Wiper::ret() const {
  // @@protoc_insertion_point(field_get:RemoNet.Wiper.ret)
  return _internal_ret();
}
inline void Wiper::_internal_set_ret(bool value) {
  
  ret_ = value;
}
inline void Wiper::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:RemoNet.Wiper.ret)
}

// -------------------------------------------------------------------

// FrontLight

// bool ret = 1;
inline void FrontLight::clear_ret() {
  ret_ = false;
}
inline bool FrontLight::_internal_ret() const {
  return ret_;
}
inline bool FrontLight::ret() const {
  // @@protoc_insertion_point(field_get:RemoNet.FrontLight.ret)
  return _internal_ret();
}
inline void FrontLight::_internal_set_ret(bool value) {
  
  ret_ = value;
}
inline void FrontLight::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:RemoNet.FrontLight.ret)
}

// -------------------------------------------------------------------

// BackLight

// bool ret = 1;
inline void BackLight::clear_ret() {
  ret_ = false;
}
inline bool BackLight::_internal_ret() const {
  return ret_;
}
inline bool BackLight::ret() const {
  // @@protoc_insertion_point(field_get:RemoNet.BackLight.ret)
  return _internal_ret();
}
inline void BackLight::_internal_set_ret(bool value) {
  
  ret_ = value;
}
inline void BackLight::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:RemoNet.BackLight.ret)
}

// -------------------------------------------------------------------

// CCAskDataChannel

// -------------------------------------------------------------------

// IMuMessage

// float rx = 1;
inline void IMuMessage::clear_rx() {
  rx_ = 0;
}
inline float IMuMessage::_internal_rx() const {
  return rx_;
}
inline float IMuMessage::rx() const {
  // @@protoc_insertion_point(field_get:RemoNet.IMuMessage.rx)
  return _internal_rx();
}
inline void IMuMessage::_internal_set_rx(float value) {
  
  rx_ = value;
}
inline void IMuMessage::set_rx(float value) {
  _internal_set_rx(value);
  // @@protoc_insertion_point(field_set:RemoNet.IMuMessage.rx)
}

// float ry = 2;
inline void IMuMessage::clear_ry() {
  ry_ = 0;
}
inline float IMuMessage::_internal_ry() const {
  return ry_;
}
inline float IMuMessage::ry() const {
  // @@protoc_insertion_point(field_get:RemoNet.IMuMessage.ry)
  return _internal_ry();
}
inline void IMuMessage::_internal_set_ry(float value) {
  
  ry_ = value;
}
inline void IMuMessage::set_ry(float value) {
  _internal_set_ry(value);
  // @@protoc_insertion_point(field_set:RemoNet.IMuMessage.ry)
}

// -------------------------------------------------------------------

// CCPing

// int64 tick = 1;
inline void CCPing::clear_tick() {
  tick_ = int64_t{0};
}
inline int64_t CCPing::_internal_tick() const {
  return tick_;
}
inline int64_t CCPing::tick() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCPing.tick)
  return _internal_tick();
}
inline void CCPing::_internal_set_tick(int64_t value) {
  
  tick_ = value;
}
inline void CCPing::set_tick(int64_t value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCPing.tick)
}

// -------------------------------------------------------------------

// CCRadarMessage

// int32 radar0 = 1;
inline void CCRadarMessage::clear_radar0() {
  radar0_ = 0;
}
inline int32_t CCRadarMessage::_internal_radar0() const {
  return radar0_;
}
inline int32_t CCRadarMessage::radar0() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRadarMessage.radar0)
  return _internal_radar0();
}
inline void CCRadarMessage::_internal_set_radar0(int32_t value) {
  
  radar0_ = value;
}
inline void CCRadarMessage::set_radar0(int32_t value) {
  _internal_set_radar0(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRadarMessage.radar0)
}

// int32 radar1 = 2;
inline void CCRadarMessage::clear_radar1() {
  radar1_ = 0;
}
inline int32_t CCRadarMessage::_internal_radar1() const {
  return radar1_;
}
inline int32_t CCRadarMessage::radar1() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRadarMessage.radar1)
  return _internal_radar1();
}
inline void CCRadarMessage::_internal_set_radar1(int32_t value) {
  
  radar1_ = value;
}
inline void CCRadarMessage::set_radar1(int32_t value) {
  _internal_set_radar1(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRadarMessage.radar1)
}

// int32 radar2 = 3;
inline void CCRadarMessage::clear_radar2() {
  radar2_ = 0;
}
inline int32_t CCRadarMessage::_internal_radar2() const {
  return radar2_;
}
inline int32_t CCRadarMessage::radar2() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRadarMessage.radar2)
  return _internal_radar2();
}
inline void CCRadarMessage::_internal_set_radar2(int32_t value) {
  
  radar2_ = value;
}
inline void CCRadarMessage::set_radar2(int32_t value) {
  _internal_set_radar2(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRadarMessage.radar2)
}

// int32 radar3 = 4;
inline void CCRadarMessage::clear_radar3() {
  radar3_ = 0;
}
inline int32_t CCRadarMessage::_internal_radar3() const {
  return radar3_;
}
inline int32_t CCRadarMessage::radar3() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRadarMessage.radar3)
  return _internal_radar3();
}
inline void CCRadarMessage::_internal_set_radar3(int32_t value) {
  
  radar3_ = value;
}
inline void CCRadarMessage::set_radar3(int32_t value) {
  _internal_set_radar3(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRadarMessage.radar3)
}

// int32 radar4 = 5;
inline void CCRadarMessage::clear_radar4() {
  radar4_ = 0;
}
inline int32_t CCRadarMessage::_internal_radar4() const {
  return radar4_;
}
inline int32_t CCRadarMessage::radar4() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRadarMessage.radar4)
  return _internal_radar4();
}
inline void CCRadarMessage::_internal_set_radar4(int32_t value) {
  
  radar4_ = value;
}
inline void CCRadarMessage::set_radar4(int32_t value) {
  _internal_set_radar4(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRadarMessage.radar4)
}

// int32 radar5 = 6;
inline void CCRadarMessage::clear_radar5() {
  radar5_ = 0;
}
inline int32_t CCRadarMessage::_internal_radar5() const {
  return radar5_;
}
inline int32_t CCRadarMessage::radar5() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRadarMessage.radar5)
  return _internal_radar5();
}
inline void CCRadarMessage::_internal_set_radar5(int32_t value) {
  
  radar5_ = value;
}
inline void CCRadarMessage::set_radar5(int32_t value) {
  _internal_set_radar5(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRadarMessage.radar5)
}

// -------------------------------------------------------------------

// CCRobotAnalog

// int32 steer = 1;
inline void CCRobotAnalog::clear_steer() {
  steer_ = 0;
}
inline int32_t CCRobotAnalog::_internal_steer() const {
  return steer_;
}
inline int32_t CCRobotAnalog::steer() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRobotAnalog.steer)
  return _internal_steer();
}
inline void CCRobotAnalog::_internal_set_steer(int32_t value) {
  
  steer_ = value;
}
inline void CCRobotAnalog::set_steer(int32_t value) {
  _internal_set_steer(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRobotAnalog.steer)
}

// int32 arm = 2;
inline void CCRobotAnalog::clear_arm() {
  arm_ = 0;
}
inline int32_t CCRobotAnalog::_internal_arm() const {
  return arm_;
}
inline int32_t CCRobotAnalog::arm() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRobotAnalog.arm)
  return _internal_arm();
}
inline void CCRobotAnalog::_internal_set_arm(int32_t value) {
  
  arm_ = value;
}
inline void CCRobotAnalog::set_arm(int32_t value) {
  _internal_set_arm(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRobotAnalog.arm)
}

// int32 bucket = 3;
inline void CCRobotAnalog::clear_bucket() {
  bucket_ = 0;
}
inline int32_t CCRobotAnalog::_internal_bucket() const {
  return bucket_;
}
inline int32_t CCRobotAnalog::bucket() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRobotAnalog.bucket)
  return _internal_bucket();
}
inline void CCRobotAnalog::_internal_set_bucket(int32_t value) {
  
  bucket_ = value;
}
inline void CCRobotAnalog::set_bucket(int32_t value) {
  _internal_set_bucket(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRobotAnalog.bucket)
}

// int32 throttle = 4;
inline void CCRobotAnalog::clear_throttle() {
  throttle_ = 0;
}
inline int32_t CCRobotAnalog::_internal_throttle() const {
  return throttle_;
}
inline int32_t CCRobotAnalog::throttle() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRobotAnalog.throttle)
  return _internal_throttle();
}
inline void CCRobotAnalog::_internal_set_throttle(int32_t value) {
  
  throttle_ = value;
}
inline void CCRobotAnalog::set_throttle(int32_t value) {
  _internal_set_throttle(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRobotAnalog.throttle)
}

// int32 brake = 5;
inline void CCRobotAnalog::clear_brake() {
  brake_ = 0;
}
inline int32_t CCRobotAnalog::_internal_brake() const {
  return brake_;
}
inline int32_t CCRobotAnalog::brake() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRobotAnalog.brake)
  return _internal_brake();
}
inline void CCRobotAnalog::_internal_set_brake(int32_t value) {
  
  brake_ = value;
}
inline void CCRobotAnalog::set_brake(int32_t value) {
  _internal_set_brake(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRobotAnalog.brake)
}

// bool emergency = 8;
inline void CCRobotAnalog::clear_emergency() {
  emergency_ = false;
}
inline bool CCRobotAnalog::_internal_emergency() const {
  return emergency_;
}
inline bool CCRobotAnalog::emergency() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRobotAnalog.emergency)
  return _internal_emergency();
}
inline void CCRobotAnalog::_internal_set_emergency(bool value) {
  
  emergency_ = value;
}
inline void CCRobotAnalog::set_emergency(bool value) {
  _internal_set_emergency(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRobotAnalog.emergency)
}

// bool resume = 9;
inline void CCRobotAnalog::clear_resume() {
  resume_ = false;
}
inline bool CCRobotAnalog::_internal_resume() const {
  return resume_;
}
inline bool CCRobotAnalog::resume() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRobotAnalog.resume)
  return _internal_resume();
}
inline void CCRobotAnalog::_internal_set_resume(bool value) {
  
  resume_ = value;
}
inline void CCRobotAnalog::set_resume(bool value) {
  _internal_set_resume(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRobotAnalog.resume)
}

// .RemoNet.Gears gears = 10;
inline void CCRobotAnalog::clear_gears() {
  gears_ = 0;
}
inline ::RemoNet::Gears CCRobotAnalog::_internal_gears() const {
  return static_cast< ::RemoNet::Gears >(gears_);
}
inline ::RemoNet::Gears CCRobotAnalog::gears() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRobotAnalog.gears)
  return _internal_gears();
}
inline void CCRobotAnalog::_internal_set_gears(::RemoNet::Gears value) {
  
  gears_ = value;
}
inline void CCRobotAnalog::set_gears(::RemoNet::Gears value) {
  _internal_set_gears(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRobotAnalog.gears)
}

// bool frontlight = 11;
inline void CCRobotAnalog::clear_frontlight() {
  frontlight_ = false;
}
inline bool CCRobotAnalog::_internal_frontlight() const {
  return frontlight_;
}
inline bool CCRobotAnalog::frontlight() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRobotAnalog.frontlight)
  return _internal_frontlight();
}
inline void CCRobotAnalog::_internal_set_frontlight(bool value) {
  
  frontlight_ = value;
}
inline void CCRobotAnalog::set_frontlight(bool value) {
  _internal_set_frontlight(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRobotAnalog.frontlight)
}

// bool backlight = 12;
inline void CCRobotAnalog::clear_backlight() {
  backlight_ = false;
}
inline bool CCRobotAnalog::_internal_backlight() const {
  return backlight_;
}
inline bool CCRobotAnalog::backlight() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRobotAnalog.backlight)
  return _internal_backlight();
}
inline void CCRobotAnalog::_internal_set_backlight(bool value) {
  
  backlight_ = value;
}
inline void CCRobotAnalog::set_backlight(bool value) {
  _internal_set_backlight(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRobotAnalog.backlight)
}

// bool wipe = 13;
inline void CCRobotAnalog::clear_wipe() {
  wipe_ = false;
}
inline bool CCRobotAnalog::_internal_wipe() const {
  return wipe_;
}
inline bool CCRobotAnalog::wipe() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCRobotAnalog.wipe)
  return _internal_wipe();
}
inline void CCRobotAnalog::_internal_set_wipe(bool value) {
  
  wipe_ = value;
}
inline void CCRobotAnalog::set_wipe(bool value) {
  _internal_set_wipe(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCRobotAnalog.wipe)
}

// -------------------------------------------------------------------

// CCBootStrapReq

// -------------------------------------------------------------------

// CCBooStrapRep

// bool ret = 1;
inline void CCBooStrapRep::clear_ret() {
  ret_ = false;
}
inline bool CCBooStrapRep::_internal_ret() const {
  return ret_;
}
inline bool CCBooStrapRep::ret() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCBooStrapRep.ret)
  return _internal_ret();
}
inline void CCBooStrapRep::_internal_set_ret(bool value) {
  
  ret_ = value;
}
inline void CCBooStrapRep::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCBooStrapRep.ret)
}

// -------------------------------------------------------------------

// CCStartupReq

// -------------------------------------------------------------------

// CCStartupRep

// bool ret = 1;
inline void CCStartupRep::clear_ret() {
  ret_ = false;
}
inline bool CCStartupRep::_internal_ret() const {
  return ret_;
}
inline bool CCStartupRep::ret() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCStartupRep.ret)
  return _internal_ret();
}
inline void CCStartupRep::_internal_set_ret(bool value) {
  
  ret_ = value;
}
inline void CCStartupRep::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCStartupRep.ret)
}

// -------------------------------------------------------------------

// CCSwitch

// bool front = 1;
inline void CCSwitch::clear_front() {
  front_ = false;
}
inline bool CCSwitch::_internal_front() const {
  return front_;
}
inline bool CCSwitch::front() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCSwitch.front)
  return _internal_front();
}
inline void CCSwitch::_internal_set_front(bool value) {
  
  front_ = value;
}
inline void CCSwitch::set_front(bool value) {
  _internal_set_front(value);
  // @@protoc_insertion_point(field_set:RemoNet.CCSwitch.front)
}

// -------------------------------------------------------------------

// LidarPoint

// optional double timestamp = 1;
inline bool LidarPoint::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LidarPoint::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void LidarPoint::clear_timestamp() {
  timestamp_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double LidarPoint::_internal_timestamp() const {
  return timestamp_;
}
inline double LidarPoint::timestamp() const {
  // @@protoc_insertion_point(field_get:RemoNet.LidarPoint.timestamp)
  return _internal_timestamp();
}
inline void LidarPoint::_internal_set_timestamp(double value) {
  _has_bits_[0] |= 0x00000002u;
  timestamp_ = value;
}
inline void LidarPoint::set_timestamp(double value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:RemoNet.LidarPoint.timestamp)
}

// optional uint32 seq = 2;
inline bool LidarPoint::_internal_has_seq() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LidarPoint::has_seq() const {
  return _internal_has_seq();
}
inline void LidarPoint::clear_seq() {
  seq_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LidarPoint::_internal_seq() const {
  return seq_;
}
inline uint32_t LidarPoint::seq() const {
  // @@protoc_insertion_point(field_get:RemoNet.LidarPoint.seq)
  return _internal_seq();
}
inline void LidarPoint::_internal_set_seq(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  seq_ = value;
}
inline void LidarPoint::set_seq(uint32_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:RemoNet.LidarPoint.seq)
}

// optional string frame_id = 3;
inline bool LidarPoint::_internal_has_frame_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LidarPoint::has_frame_id() const {
  return _internal_has_frame_id();
}
inline void LidarPoint::clear_frame_id() {
  frame_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LidarPoint::frame_id() const {
  // @@protoc_insertion_point(field_get:RemoNet.LidarPoint.frame_id)
  return _internal_frame_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LidarPoint::set_frame_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.LidarPoint.frame_id)
}
inline std::string* LidarPoint::mutable_frame_id() {
  std::string* _s = _internal_mutable_frame_id();
  // @@protoc_insertion_point(field_mutable:RemoNet.LidarPoint.frame_id)
  return _s;
}
inline const std::string& LidarPoint::_internal_frame_id() const {
  return frame_id_.Get();
}
inline void LidarPoint::_internal_set_frame_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LidarPoint::_internal_mutable_frame_id() {
  _has_bits_[0] |= 0x00000001u;
  return frame_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LidarPoint::release_frame_id() {
  // @@protoc_insertion_point(field_release:RemoNet.LidarPoint.frame_id)
  if (!_internal_has_frame_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = frame_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (frame_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    frame_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LidarPoint::set_allocated_frame_id(std::string* frame_id) {
  if (frame_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  frame_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), frame_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (frame_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    frame_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.LidarPoint.frame_id)
}

// optional uint32 height = 4;
inline bool LidarPoint::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LidarPoint::has_height() const {
  return _internal_has_height();
}
inline void LidarPoint::clear_height() {
  height_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LidarPoint::_internal_height() const {
  return height_;
}
inline uint32_t LidarPoint::height() const {
  // @@protoc_insertion_point(field_get:RemoNet.LidarPoint.height)
  return _internal_height();
}
inline void LidarPoint::_internal_set_height(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  height_ = value;
}
inline void LidarPoint::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:RemoNet.LidarPoint.height)
}

// optional uint32 width = 5;
inline bool LidarPoint::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LidarPoint::has_width() const {
  return _internal_has_width();
}
inline void LidarPoint::clear_width() {
  width_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LidarPoint::_internal_width() const {
  return width_;
}
inline uint32_t LidarPoint::width() const {
  // @@protoc_insertion_point(field_get:RemoNet.LidarPoint.width)
  return _internal_width();
}
inline void LidarPoint::_internal_set_width(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  width_ = value;
}
inline void LidarPoint::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:RemoNet.LidarPoint.width)
}

// optional bool is_dense = 6;
inline bool LidarPoint::_internal_has_is_dense() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LidarPoint::has_is_dense() const {
  return _internal_has_is_dense();
}
inline void LidarPoint::clear_is_dense() {
  is_dense_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool LidarPoint::_internal_is_dense() const {
  return is_dense_;
}
inline bool LidarPoint::is_dense() const {
  // @@protoc_insertion_point(field_get:RemoNet.LidarPoint.is_dense)
  return _internal_is_dense();
}
inline void LidarPoint::_internal_set_is_dense(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_dense_ = value;
}
inline void LidarPoint::set_is_dense(bool value) {
  _internal_set_is_dense(value);
  // @@protoc_insertion_point(field_set:RemoNet.LidarPoint.is_dense)
}

// optional bool is_left = 7;
inline bool LidarPoint::_internal_has_is_left() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LidarPoint::has_is_left() const {
  return _internal_has_is_left();
}
inline void LidarPoint::clear_is_left() {
  is_left_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool LidarPoint::_internal_is_left() const {
  return is_left_;
}
inline bool LidarPoint::is_left() const {
  // @@protoc_insertion_point(field_get:RemoNet.LidarPoint.is_left)
  return _internal_is_left();
}
inline void LidarPoint::_internal_set_is_left(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_left_ = value;
}
inline void LidarPoint::set_is_left(bool value) {
  _internal_set_is_left(value);
  // @@protoc_insertion_point(field_set:RemoNet.LidarPoint.is_left)
}

// repeated float data = 8;
inline int LidarPoint::_internal_data_size() const {
  return data_.size();
}
inline int LidarPoint::data_size() const {
  return _internal_data_size();
}
inline void LidarPoint::clear_data() {
  data_.Clear();
}
inline float LidarPoint::_internal_data(int index) const {
  return data_.Get(index);
}
inline float LidarPoint::data(int index) const {
  // @@protoc_insertion_point(field_get:RemoNet.LidarPoint.data)
  return _internal_data(index);
}
inline void LidarPoint::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:RemoNet.LidarPoint.data)
}
inline void LidarPoint::_internal_add_data(float value) {
  data_.Add(value);
}
inline void LidarPoint::add_data(float value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:RemoNet.LidarPoint.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
LidarPoint::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
LidarPoint::data() const {
  // @@protoc_insertion_point(field_list:RemoNet.LidarPoint.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
LidarPoint::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
LidarPoint::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:RemoNet.LidarPoint.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// SensorStop

// -------------------------------------------------------------------

// StopAck

// -------------------------------------------------------------------

// CCManipulation

// bytes sensor = 1;
inline void CCManipulation::clear_sensor() {
  sensor_.ClearToEmpty();
}
inline const std::string& CCManipulation::sensor() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCManipulation.sensor)
  return _internal_sensor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CCManipulation::set_sensor(ArgT0&& arg0, ArgT... args) {
 
 sensor_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.CCManipulation.sensor)
}
inline std::string* CCManipulation::mutable_sensor() {
  std::string* _s = _internal_mutable_sensor();
  // @@protoc_insertion_point(field_mutable:RemoNet.CCManipulation.sensor)
  return _s;
}
inline const std::string& CCManipulation::_internal_sensor() const {
  return sensor_.Get();
}
inline void CCManipulation::_internal_set_sensor(const std::string& value) {
  
  sensor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CCManipulation::_internal_mutable_sensor() {
  
  return sensor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CCManipulation::release_sensor() {
  // @@protoc_insertion_point(field_release:RemoNet.CCManipulation.sensor)
  return sensor_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CCManipulation::set_allocated_sensor(std::string* sensor) {
  if (sensor != nullptr) {
    
  } else {
    
  }
  sensor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sensor,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sensor_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sensor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.CCManipulation.sensor)
}

// bytes car = 2;
inline void CCManipulation::clear_car() {
  car_.ClearToEmpty();
}
inline const std::string& CCManipulation::car() const {
  // @@protoc_insertion_point(field_get:RemoNet.CCManipulation.car)
  return _internal_car();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CCManipulation::set_car(ArgT0&& arg0, ArgT... args) {
 
 car_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoNet.CCManipulation.car)
}
inline std::string* CCManipulation::mutable_car() {
  std::string* _s = _internal_mutable_car();
  // @@protoc_insertion_point(field_mutable:RemoNet.CCManipulation.car)
  return _s;
}
inline const std::string& CCManipulation::_internal_car() const {
  return car_.Get();
}
inline void CCManipulation::_internal_set_car(const std::string& value) {
  
  car_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CCManipulation::_internal_mutable_car() {
  
  return car_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CCManipulation::release_car() {
  // @@protoc_insertion_point(field_release:RemoNet.CCManipulation.car)
  return car_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CCManipulation::set_allocated_car(std::string* car) {
  if (car != nullptr) {
    
  } else {
    
  }
  car_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), car,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (car_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    car_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoNet.CCManipulation.car)
}

// -------------------------------------------------------------------

// SCAddRobot

// .RemoNet.Robot robot = 1;
inline bool SCAddRobot::_internal_has_robot() const {
  return this != internal_default_instance() && robot_ != nullptr;
}
inline bool SCAddRobot::has_robot() const {
  return _internal_has_robot();
}
inline void SCAddRobot::clear_robot() {
  if (GetArenaForAllocation() == nullptr && robot_ != nullptr) {
    delete robot_;
  }
  robot_ = nullptr;
}
inline const ::RemoNet::Robot& SCAddRobot::_internal_robot() const {
  const ::RemoNet::Robot* p = robot_;
  return p != nullptr ? *p : reinterpret_cast<const ::RemoNet::Robot&>(
      ::RemoNet::_Robot_default_instance_);
}
inline const ::RemoNet::Robot& SCAddRobot::robot() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCAddRobot.robot)
  return _internal_robot();
}
inline void SCAddRobot::unsafe_arena_set_allocated_robot(
    ::RemoNet::Robot* robot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_);
  }
  robot_ = robot;
  if (robot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RemoNet.SCAddRobot.robot)
}
inline ::RemoNet::Robot* SCAddRobot::release_robot() {
  
  ::RemoNet::Robot* temp = robot_;
  robot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RemoNet::Robot* SCAddRobot::unsafe_arena_release_robot() {
  // @@protoc_insertion_point(field_release:RemoNet.SCAddRobot.robot)
  
  ::RemoNet::Robot* temp = robot_;
  robot_ = nullptr;
  return temp;
}
inline ::RemoNet::Robot* SCAddRobot::_internal_mutable_robot() {
  
  if (robot_ == nullptr) {
    auto* p = CreateMaybeMessage<::RemoNet::Robot>(GetArenaForAllocation());
    robot_ = p;
  }
  return robot_;
}
inline ::RemoNet::Robot* SCAddRobot::mutable_robot() {
  ::RemoNet::Robot* _msg = _internal_mutable_robot();
  // @@protoc_insertion_point(field_mutable:RemoNet.SCAddRobot.robot)
  return _msg;
}
inline void SCAddRobot::set_allocated_robot(::RemoNet::Robot* robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete robot_;
  }
  if (robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RemoNet::Robot>::GetOwningArena(robot);
    if (message_arena != submessage_arena) {
      robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    
  } else {
    
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:RemoNet.SCAddRobot.robot)
}

// -------------------------------------------------------------------

// SCDelRobot

// int32 peer = 1;
inline void SCDelRobot::clear_peer() {
  peer_ = 0;
}
inline int32_t SCDelRobot::_internal_peer() const {
  return peer_;
}
inline int32_t SCDelRobot::peer() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCDelRobot.peer)
  return _internal_peer();
}
inline void SCDelRobot::_internal_set_peer(int32_t value) {
  
  peer_ = value;
}
inline void SCDelRobot::set_peer(int32_t value) {
  _internal_set_peer(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCDelRobot.peer)
}

// int32 egotype = 2;
inline void SCDelRobot::clear_egotype() {
  egotype_ = 0;
}
inline int32_t SCDelRobot::_internal_egotype() const {
  return egotype_;
}
inline int32_t SCDelRobot::egotype() const {
  // @@protoc_insertion_point(field_get:RemoNet.SCDelRobot.egotype)
  return _internal_egotype();
}
inline void SCDelRobot::_internal_set_egotype(int32_t value) {
  
  egotype_ = value;
}
inline void SCDelRobot::set_egotype(int32_t value) {
  _internal_set_egotype(value);
  // @@protoc_insertion_point(field_set:RemoNet.SCDelRobot.egotype)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace RemoNet

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::RemoNet::Robot_RobotState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RemoNet::Robot_RobotState>() {
  return ::RemoNet::Robot_RobotState_descriptor();
}
template <> struct is_proto_enum< ::RemoNet::CSMessage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RemoNet::CSMessage>() {
  return ::RemoNet::CSMessage_descriptor();
}
template <> struct is_proto_enum< ::RemoNet::SCMessage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RemoNet::SCMessage>() {
  return ::RemoNet::SCMessage_descriptor();
}
template <> struct is_proto_enum< ::RemoNet::CCMessage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RemoNet::CCMessage>() {
  return ::RemoNet::CCMessage_descriptor();
}
template <> struct is_proto_enum< ::RemoNet::VideoDesc> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RemoNet::VideoDesc>() {
  return ::RemoNet::VideoDesc_descriptor();
}
template <> struct is_proto_enum< ::RemoNet::Gears> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RemoNet::Gears>() {
  return ::RemoNet::Gears_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
